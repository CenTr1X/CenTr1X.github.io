<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>《计算机网络-自顶向下方法》学习笔记-第3章 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第3章 《传输层》3.1 概述和传输层服务传输层协议为运行在不同主机上的应用提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直接相连一样。传输层中的分组称为传输层报文段（segment）。传输层讲这些报文段传递给网络层，网络层将其封装称为网络层分组，即数据报并向目的地发送。网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在该数据报的传输层报文段的字段。传输层只工作在端系统中，传输协议能">
<meta property="og:type" content="article">
<meta property="og:title" content="《计算机网络-自顶向下方法》学习笔记-第3章">
<meta property="og:url" content="http://example.com/2020/02/03/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第3章 《传输层》3.1 概述和传输层服务传输层协议为运行在不同主机上的应用提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直接相连一样。传输层中的分组称为传输层报文段（segment）。传输层讲这些报文段传递给网络层，网络层将其封装称为网络层分组，即数据报并向目的地发送。网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在该数据报的传输层报文段的字段。传输层只工作在端系统中，传输协议能">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-03T05:14:29.000Z">
<meta property="article:modified_time" content="2021-05-29T15:36:51.494Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-《计算机网络-自顶向下方法》学习笔记-第3章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/03/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2020-02-03T05:14:29.000Z" itemprop="datePublished">2020-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《计算机网络-自顶向下方法》学习笔记-第3章
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第3章-《传输层》"><a href="#第3章-《传输层》" class="headerlink" title="第3章 《传输层》"></a>第3章 《传输层》</h2><h3 id="3-1-概述和传输层服务"><a href="#3-1-概述和传输层服务" class="headerlink" title="3.1 概述和传输层服务"></a>3.1 概述和传输层服务</h3><p>传输层协议为运行在不同主机上的应用提供了<strong>逻辑通信</strong>。通过逻辑通信，运行不同进程的主机好像直接相连一样。传输层中的分组称为<strong>传输层报文段（segment）</strong>。传输层讲这些报文段传递给网络层，网络层将其封装称为网络层分组，即数据报并向目的地发送。网络路由器仅作用于该数据报的网络层字段，即它们不检查封装在该数据报的传输层报文段的字段。传输层<strong>只工作在端系统</strong>中，传输协议能提供的服务常常受制于网络层协议的服务模型。UDP（用户数据报协议）为应用程序提供了一种<strong>不可靠，无连接</strong>的服务，TCP（传输控制协议）为应用程序提供了<strong>可靠的，面向连接的服务</strong>。IP的服务模型为尽力而为交付服务，即IP尽最大努力在主机之间交付报文段但不做任何保证，因此<strong>IP被称作不可靠服务</strong>。每台主机都有一个IP地址。将主机间交付扩展到进程间交付被称为<strong>传输层的多路复用和多路分解</strong>。进程到进程的<strong>数据交付和差错检查</strong>是两种最低限度的传输层服务，也是UDP能提供的仅有的服务。TCP提供了几种附加服务，如通过使用流量控制，序号，确认和定时器以提供可靠数据传输，拥塞控制等。</p>
<h3 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h3><p>一个进程有一个或多个套接字，它相对于从网络中向进程传递数据和从进程向网络传递数据的门户。将传输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>，在源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息而生成报文段，然后将报文段传输到网络层中称为<strong>多路复用</strong>。</p>
<p>传输层多路复用的要求有：1.<strong>套接字有唯一标识符</strong>2.每个报文段有<strong>特殊字段</strong>指示该报文段需要交付到的套接字。这些特殊字段是<strong>源端口号字段</strong>和<strong>目的端口号字段</strong>。<strong>端口号</strong>是一个<strong>16比特</strong>的数，大小在<strong>0-65535</strong>之间，0-1023之间的端口号称为<strong>周知端口号（公认端口号）</strong>，是受限制的，被保留给诸如HTTP（80端口）和FTP（21端口）之类周知协议所使用。</p>
<p>一个UDP套接字是由一个<strong>二元组</strong>标识的，包括一个<strong>目的IP地址</strong>和一个<strong>目的端口号</strong>。故如果两个UDP报文段有不同的源IP地址和源端口号，但目的IP地址和目的端口号相同，则这两个报文段将通过相同的目的套接字被定向到相同的进程。一个TCP套接字是由一个<strong>四元组</strong>（<strong>源IP地址，源端口号，目的IP地址，目的端口号</strong>）来标识的。两个具有不同源IP地址或源端口号的TCP报文段将被定向到不同的套接字。当一个TCP报文段到达主机时，所有4个字段将被用来将报文段分解到相应的套接字。连接套接字与进程<strong>并非总是有着一一对应</strong>的关系。</p>
<h3 id="3-3-无连接传输：UDP"><a href="#3-3-无连接传输：UDP" class="headerlink" title="3.3 无连接传输：UDP"></a>3.3 无连接传输：UDP</h3><p>使用UDP时，在发送报文段前，发送方和接收方的传输层实体之间并没有握手，故UDP是<strong>无连接</strong>的。采用UDP时，只要应用程序将数据传递给UDP，UDP就会将此数据打包加入UDP报文段并<strong>立即将其传递给网络层</strong>。UDP<strong>不会引入建立连接的时延</strong>。UDP<strong>不维护连接状态</strong>，也不跟踪这些参数。UDP的<strong>分组首部开销较小</strong>。</p>
<p>在UDP报文中，<strong>应用层数据占用UDP报文段的数据字段</strong>。UDP<strong>首部只有4个字段</strong>，每个字段由<strong>两个字节</strong>组成，分别为<strong>源端口号，目的端口号，长度，检验和</strong>四个字段。通过端口号可以使目的主机将数据交给相应的进程，即只需分解功能，长度字段指示了UDP报文段中的全部字符数。</p>
<p><strong>UDP检验和提供了差错检测功能</strong>。发送方对报文段中的所有16比特字的<strong>和</strong>进行<strong>取反运算</strong>，求和时采用<strong>循环进位</strong>，得到的结果放在UDP报文段中的检验和字段。虽然UDP提供差错检测，但其无法进行差错恢复。</p>
<h3 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h3><p>记<strong>经完全可靠信道的可靠数据传输协议为rdt1.0</strong>。rdt的发送端只通过rdt_send(data)接收来自较高层的数据，通过make_pkt(data)产生一个包含数据的分组，并将分组发送到信道中。在接收端，rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，从分组中通过extract(packet,data)取出数据，并将数据通过deliver_data(data)传输给较高层。</p>
<p>记<strong>经具有比特差错信道的可靠数据传输协议为rdt2.0</strong>。在计算机网络中，<strong>基于肯定确认与否定确认的重传机制的可靠数据传输协议称为自动重传协议(ARQ)<strong>。ARQ中需要</strong>差错检测，接收方反馈和重传</strong>三种协议功能处理比特差错的情况。rdt2.0的发送端由两个状态。当rdt_send(data)出现时，发送方产生一个包含待发送数据的分组，带有校验和，通过udt_send(sndpkt)发送，而后转入等待ACK或NAK的状态。若收到ACK，说明最近发送的分组已被正确接收，因此协议返回到等待上层调用的状态，若收到NAK分组，该协议重传上一个分组并继续等待ACK或NAK。当发送方处于<strong>等待ACK或NAK状态时，它不能从上层获得更多数据</strong>，因此rdt2.0被称为<strong>停等协议</strong>。rdt2.0的接收方的FSM(有限状态机)只有一个状态，即分组到达时回答ACK或NAK。</p>
<p>rdt2.0没有考虑ACK或NAK分组受损的可能。若采取<strong>冗余分组</strong>的方法，其根本困难在于接收方不知道它上次所发送的的ACK或NAK是否被发送方正确接收，故无法知道收到的分组是新的还是重传的。在数据分组中添加新字段，即让发送方对其数据分组编号，将发送分组的序号放在该字段，即可解决该问题。发送方接收到对同一个分组的两个ACK后，就知道接收方没有正确接收到跟在被确认两次分组后所发送的分组。</p>
<p>记<strong>经具有比特差错的丢包信道的可靠数据传输协议为rdt3.0</strong>。rdt3.0中，为了实现基于时间的重传机制，需要一个<strong>倒计时计数器</strong>，在一个给定的时间量过期后，可中断发送方。因为rdt3.0中分组序号在0和1之间交替，故rdt3.0也被称为<strong>比特交替协议</strong>。</p>
<p>rdt3.0功能正确，但因为其是停等协议，性能不佳。定义<strong>发送方的利用率</strong>为发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比，停等协议有很低的利用率。可采用流水线技术改进可靠数据传输协议，引入流水线则需要1.<strong>增加序号范围</strong>2.<strong>协议的发送方和接收方两端需要缓存多个分组</strong>3.<strong>所需序号范围和对缓冲的要求取决于协议如何处理丢失，损坏和延时过大的分组</strong>。解决流水线的差错恢复的两种基本方法是**回退N步(GBN)<strong>和</strong>选择重传(SR)**。</p>
<p>在回退N步(GBN)协议中，<strong>允许发送方发送多个分组而不需要等待确认</strong>，但它也受限于在流水线中<strong>未确认的分组数不能超过某个最大允许数N</strong>。我们将<strong>基序号定义为最早未确认分组的序号</strong>，将<strong>下一个序号定义为最小未使用序号</strong>。N<strong>常被称为窗口长度，GBN协议常被称为滑动窗口协议</strong>。在GBN协议中，发送方必须响应三种事件，即1.<strong>上层调用</strong>：发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则发送一个分组并相应更新变量；2.<strong>收到一个ACK</strong>：GBN中对分组确认采用累计确认的方式，即表明接收方已正确接收序号n的以前包括n在内的所有分组；3.<strong>超时事件</strong>：若出现超时，发送方重传所有已发送但未被确认的分组。若收到一个ACK，但仍有已发送未确认的分组，则定时器被重启，若无这种分组，则停止计时器。对于接收方，如果一个序号为n的分组被正确且按序收到（即上一个交付给上层的分组序号为n-1），则接收方为分组n发送一个ACK，并交付数据到上层。在其它任何情况下，接收方都丢弃该分组，并按最近按序接收的分组重新发送ACK，即接收方<strong>丢弃所有失序分组</strong>。</p>
<p>选择重传（SR）协议通过让发送方<strong>仅重传那些它怀疑丢失或受损的分组</strong>而避免了不必要的重传。此时接收方将确认正确接收的分组而不管其是否按序，失序的分组将被<strong>缓存</strong>。对于发送方，现在每个分组都需要有自己的逻辑定时器。当发送方收到ACK时，若该分组序号在窗口内，则发送方将被确认的分组标记为已接收，若分组序号等于基序号，则基序号向前移动到具有最小序号的未确认分组处，若窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。对于接收方，若正确接收到接收窗口内的分组，缓存未收过的分组，若分组序号为基序号，则向上交付。若正确接收基序号前一个窗口长度中的分组，则产生一个ACK。在其他情况下，接收方都忽略分组。窗口长度必须<strong>小于或等于序号空间的一半</strong>。由于序号可被重新使用，实际中的做法是在发送方确信任何先前发送的序号为x的分组都不会在网络中前，确保一个序号不被重复使用。这通过假定一个分组在网络中的存活时间不会超过某个固定值来实现。</p>
<h3 id="3-5-面向连接的传输-TCP"><a href="#3-5-面向连接的传输-TCP" class="headerlink" title="3.5 面向连接的传输: TCP"></a>3.5 面向连接的传输: TCP</h3><p>TCP提供的是<strong>面向连接的，全双工服务</strong>，即如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在进程B到A的同时也从A流向B。TCP链接是点对点的。建立TCP连接时，前两个报文段不承载有效载荷，即不包含应用层数据，<strong>第三个报文段可包含有效载荷</strong>。连接过程的建立被称为<strong>三次握手</strong>。数据通过套接字后，TCP将其引导到连接的发送缓存中。TCP从缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度（MSS）</strong>，MSS通常需要根据由本地发送主机发送的最大链路层帧长度（最大传输单元MTU）来设置。MSS的典型值为1460字节。注意<strong>MSS指的是报文段中应用层数据的最大长度</strong>。</p>
<p>TCP报文段由首部字段和一个数据字段构成。与UDP一样，首部字段包括了源端口号和目的端口号以及检验和字段。首部字段中包含下列字段：1.<strong>32比特的序号字段和32比特的确认号字段</strong>。2.<strong>16比特的接收窗口字段</strong>，该字段用于流量控制，指示接收方愿意接受的字节数量。3.<strong>4比特的首部长度字段</strong>，指示以32比特为单位的TCP首部长度。4.<strong>可选与变长的选项字段</strong>，用于协商MSS或作为窗口调节因子时使用。5.<strong>6比特的标志字段</strong>，其中ACK比特用于指示确认字段中的值是有效的，即该报文段中包含一个对先前报文段的确认，RST，SYN，FIN比特用于连接的建立和断开。明确拥塞通告中使用了CWR和ECE比特。PSH比特指示接收方立即将数据交给上层，URG比特指示报文段里存在着被发送端的上层标志为紧急的数据。</p>
<p>TCP报文段首部中最重要的两个字段是<strong>序号字段和确认号字段</strong>。一个报文段的序号是该报文段<strong>首字节的字节流编号</strong>。接收方主机填入报文段的确认号是接收方主机<strong>期望接收到的下一字节的序号</strong>。因为TCP只确认该流中至第一个丢失字节为止的字节，故称TCP为提供<strong>累积确认</strong>。Telent是一个用于远程登录的流行应用层协议。Telnet中对客户到服务器的数据的确认被装载到一个承载服务器到客户数据的报文段中，这种确认被称为是<strong>捎带</strong>在服务器到客户的数据报文段中的。</p>
<p>报文段的<strong>样本RTT</strong>（即SampleRTT）就是从某报文段被发出到对该报文段的确认被收到之间的时间量。<strong>预测的RTT值</strong>为以前的预测RTT与SampleRTT加权组合而成，即：</p>
<p>[latex display=’true’]EstimatedRTT=(1-\alpha)\cdot EstimatedRTT + \alpha \cdot SampleRTT[/latex]</p>
<p>RFC 6298中给出α的推荐值为0.125，该加权平均对最近的样本赋予更多的权值，因为越近的样本能越好的反应当前网络的拥塞状况，这种平均被称为<strong>指数加权移动平均（EWMA）</strong>。此外计算RTT的偏移量，即<strong>DevRTT</strong>也可对网络状态评估有所帮助，DevRTT是一个SampleRTT和EstimatedRTT之间差值的EWMA，即：</p>
<p>[latex display=’true’]DevRTT=(1-\beta )\cdot DevRTT + \beta \cdot \left SampleRTT-EstimatedRTT\right [/latex]</p>
<p>其中β的参考值为0.25。一般将超时间隔设为EstimatedRTT加上一定余量。当DevRTT较大时，余量较大。一般初始的重传时间为1s。</p>
<p>TCP的可靠数据传输服务确保了一个进程从其接收缓存中读取出的数据流是无损坏，无间隙，非冗余和按序的数据流，即该字节流和连接的另一方端系统发出的字节流是完全相同的。推荐的定时器管理过程仅使用<strong>单一的重传定时器</strong>。<strong>每次TCP重传都会将下一次的超时间隔设为先前值的两倍，这提供了一定程度的拥塞控制</strong>。发送方可在超时事件发生之前通过接收冗余ACK来检测到丢包情况。冗余ACK是指再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。<strong>如果TCP发送方接收到对相同数据的3个冗余ACK，它把作为对跟在该报文段后的分组已经丢失的指示</strong>。一旦收到3个冗余ACK，TCP就执行<strong>快速重传</strong>，即在该报文段的定时器过期之前重传丢失的报文段。TCP的差错恢复机制类似于GBN协议与SR协议的混合。一种对TCP的修改意见是选择确认，即允许TCP接收方有选择地确认失序报文段，而不是累计确认最后一个正确接收的报文段。</p>
<p>TCP为应用程序提供了<strong>流量控制服务</strong>，以<strong>消除发送方使得接收方缓存溢出的</strong>可能。流量控制是一个<strong>速度匹配服务</strong>，即发送方的接收速率和接收方应用程序的读取速率向匹配。因为IP网络的拥塞对发送方速率的遏制叫做<strong>拥塞控制</strong>。TCP通过让发送方维护一个称为<strong>接收窗口</strong>的变量实现流量控制。通过<strong>将未确认数据量控制在rwnd（接收窗口大小）内</strong>，就可以保证发送方不会使接收方的接收缓存溢出。TCP规范中要求，当接收窗口为0时，发送方继续发送只有一个字节数据的报文段。</p>
<p>客户与服务器中的TCP建立连接需要<strong>三个步骤</strong>：1.客户端的TCP首先向服务器端TCP发送一个特定的TCP报文段，该报文段不包含应用层数据。在该报文段首部中SYN比特被置位，因此称为该报文段为<strong>SYN报文段</strong>。客户随机选择一个初始序号，将其放置于SYN报文段的序号字段中。2.服务器提取出SYN报文段，为其分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。该报文段的SYN比特被置位，确认号字段为客户所选择的初始序号+1。服务器随机选择自己的初始序号，将其放到首部的序号字段中。该允许连接的报文段被称为<strong>SYNACK报文段</strong>。3.客户向主机发送<strong>对服务器允许连接的报文段进行确认的报文段</strong>，这里通过将服务器所选序号+1放在首部确认字段来完成。此时SYN比特置为0，该阶段的报文段可承载有效载荷。建立连接之后每一个报文段SYN字段都为0，这种创建连接的过程称为<strong>三次握手</strong>。</p>
<p>关闭TCP连接时，客户TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部的一个标志位即<strong>FIN比特</strong>被置位。服务器收到该报文段后，发送一个确认报文段。然后服务器发送自己的终止报文段，FIN比特被置位，随后客户对该终止报文段进行确认。断开连接过程称为四次挥手。</p>
<p>在一个TCP连接的生命周期里，运行在每台主机上的TCP协议在各种TCP状态之间变化。假如一台主机接受了具有目的端口号80的一个TCP SYN分组，但该主机在80端口不接受连接，则该主机发送一个重置报文段，该报文段将<strong>RST标志位</strong>置为1。</p>
<h3 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h3><p>运行在发送方的TCP拥塞控制机制维护拥塞窗口变量。<strong>拥塞窗口表示为cwnd</strong>，它对一个TCP发送方能向网络中发送流量的速率进行了限制，即在一个发送方中未确认的数据量<strong>不会超过cwnd和rwnd的最小值</strong>。通过调节cwnd的值，发送方能调整它向连接发送数据的速率。因为TCP采用确认来触发增大它的拥塞窗口长度，所以TCP被称为<strong>自计时的</strong>。TCP使用以下原则指导拥塞控制：1.一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。2.一个确认报文段指示网络正在向接收方交付发送方的报文段，因此当先前未确认报文段到达时，能增加发送方的速率。3.带宽探测。</p>
<p>在TCP拥塞控制原则的指导下，给出了TCP拥塞控制算法。该算法主要包括三个部分：1.<strong>慢启动</strong>2.<strong>拥塞避免</strong>3.<strong>快速恢复</strong>。其中慢启动和拥塞避免是TCP的强制部分，快速恢复是推荐部分。</p>
<p>在<strong>慢启动</strong>状态，cwnd以一个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。TCP的初始发送速率慢，但在慢启动阶段以指数增长。如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重新开始慢启动过程，还将ssthresh（慢启动阈值）设置为cwnd/2。当cwnd的值到达或超过ssthresh时，结束慢启动阶段并且将TCP转移到拥塞避免模式。当检测到3个冗余ACK时，TCP执行快速重传，进入快速恢复状态。</p>
<p><strong>拥塞避免</strong>阶段cwnd增长速度较慢。该阶段中，每个RTT只将cwnd的值增长一个MSS。一种方法是无论何时到达一个新的确认，就将cwnd增加一个MSS*(MSS/cwnd)。当出现超时时，cwnd被设为1个MSS，ssthresh被更新为cwnd的一半。当发生3个冗余ACK指示的丢包时，将ssthresh设为cwnd的一半，将cwnd设为ssthresh加上3倍MSS的值，进入快速恢复阶段。</p>
<p>在<strong>快速恢复</strong>阶段中，对每个收到的冗余ACK，cwnd的值增加一个MSS。在对丢失报文段的的一个确认ACK到达后，TCP将cwnd的值降低为ssthresh，进入拥塞避免状态。若出现超时事件，TCP同样将ssthresh设为cwnd的一半，再将cwnd设为1，进入慢启动状态。</p>
<p>TCP的拥塞控制常常被称为<strong>加性增，乘性减（AIMD）</strong>的拥塞控制方式。TCP vegas算法试图在维持较好的吞吐量的同时避免拥塞，其基本思想为：1.在分组丢失发生之前，在源与目的之间检测路由器中的拥塞2.当检测出即将发生的丢包时，线性的降低发送速率。即将发生的分组丢失是通过RTT检测。假设连接期间RTT和W几乎不变，则传输速率在W/(2RTT)到W/RTT之间变化。</p>
<p>瓶颈链路是指对于每条连接，沿着该连接路径上的所有其它端链路都不拥塞，而且与该瓶颈链路的传输容量相比，它们都有充足的容量。若每条连接的都得到相同的链路带宽，则认为该拥塞控制机制是公平的。TCP趋于在竞争的多条TCP连接之间<strong>提供对一段瓶颈链路带宽的平等分享</strong>。UDP有可能压制TCP流量。明确拥塞通告（ECN）是一种网络辅助拥塞控制，该方案允许网络明确向TCP发送方和接收方发送拥塞信号。数据报拥塞控制协议（DCCP）是一种提供了低开销，控制拥塞的类似UDP的不可靠协议。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/03/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0/" data-id="cksrngqtz000oq4w0hm4oam4x" data-title="《计算机网络-自顶向下方法》学习笔记-第3章" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/02/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          《计算机网络-自顶向下方法》学习笔记-第4章
        
      </div>
    </a>
  
  
    <a href="/2020/01/18/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《计算机网络-自顶向下方法》学习笔记--第2章</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cybersecurity/">Cybersecurity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%89%E5%85%A8%E6%BC%94%E7%BB%83%E4%B8%AD%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">记一次安全演练中的渗透测试</a>
          </li>
        
          <li>
            <a href="/2020/11/02/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于反序列化漏洞的一点思考</a>
          </li>
        
          <li>
            <a href="/2020/03/09/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC5%E7%AB%A0/">《计算机网络-自顶向下方法》学习笔记-第5章</a>
          </li>
        
          <li>
            <a href="/2020/03/02/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0/">《计算机网络-自顶向下方法》学习笔记-第4章</a>
          </li>
        
          <li>
            <a href="/2020/02/03/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0/">《计算机网络-自顶向下方法》学习笔记-第3章</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>